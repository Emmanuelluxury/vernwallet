<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bitcoin-Starknet Bridge | Bridge Dashboard</title>
    <link rel="icon" href="../images/image.png" type="image/x-icon">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">

    <style>
        :root {
            --primary: #7c3aed;
            --primary-dark: #6d28d9;
            --primary-light: rgba(124, 58, 237, 0.15);
            --secondary: #10b981;
            --dark: #0f172a;
            --darker: #0a0f1c;
            --light: #f9fafb;
            --lighter: #ffffff;
            --gray: #94a3b8;
            --gray-light: rgba(148, 163, 184, 0.2);
            --danger: #ef4444;
            --warning: #f59e0b;
            --info: #3b82f6;
            --bitcoin: #f7931a;
            --starknet: #7c3aed;
            --border-radius: 16px;
            --card-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            --transition: all 0.3s ease;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, var(--darker) 0%, #0c1424 100%);
            color: var(--light);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            width: 100%;
        }
        
        /* Animated Background */
        .animated-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.3;
            background: 
                radial-gradient(circle at 20% 30%, rgba(124, 58, 237, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(16, 185, 129, 0.1) 0%, transparent 50%);
        }
        
        /* Glow effects */
        .glow {
            position: absolute;
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: radial-gradient(var(--primary), transparent 70%);
            opacity: 0.05;
            filter: blur(40px);
            z-index: -1;
        }
        
        .glow-1 {
            top: 10%;
            right: 10%;
        }
        
        .glow-2 {
            bottom: 10%;
            left: 10%;
        }
        
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 30px;
        }

        .wallet-buttons {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 15px;
            transition: var(--transition);
        }
        
        .logo:hover {
            transform: translateY(-1px);
        }
        
        .logo-icon {
            font-size: 2.5rem;
            color: var(--primary);
            background: var(--primary-light);
            width: 50px;
            height: 50px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .logo-text {
            font-size: 1.8rem;
            font-weight: 800;
            background: linear-gradient(to right, var(--primary), #6d28d9);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        nav ul {
            display: flex;
            list-style: none;
            gap: 30px;
        }
        
        nav a {
            color: rgba(255, 255, 255, 0.7);
            text-decoration: none;
            font-weight: 500;
            transition: var(--transition);
            padding: 10px 15px;
            border-radius: 8px;
            position: relative;
        }
        
        nav a:hover, nav a.active {
            color: var(--primary);
        }
        
        nav a.active::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 4px;
            height: 4px;
            background: var(--primary);
            border-radius: 50%;
        }
        
        .dashboard-title {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-align: center;
            background: linear-gradient(to right, var(--primary), var(--primary-light));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: 800;
            position: relative;
            display: inline-block;
            width: 100%;
        }
        
        .dashboard-title::after {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 3px;
            background: var(--primary);
            border-radius: 3px;
        }
        
        .subtitle {
            text-align: center;
            color: var(--gray);
            margin-bottom: 40px;
            font-size: 1.1rem;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
            line-height: 1.6;
        }
        
        .bridge-container {
            display: flex;
            flex-direction: column;
            max-width: 900px;
            margin: 0 auto;
            gap: 30px;
        }
        
        .bridge-card {
            background: rgba(15, 23, 42, 0.7);
            backdrop-filter: blur(15px);
            border-radius: var(--border-radius);
            padding: 30px;
            border: 1px solid rgba(124, 58, 237, 0.1);
            transition: var(--transition);
            box-shadow: var(--card-shadow);
            position: relative;
            overflow: hidden;
        }
        
        .bridge-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: linear-gradient(90deg, var(--primary), transparent);
        }
        
        .bridge-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.3);
            border-color: rgba(124, 58, 237, 0.3);
        }
        
        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
        }
        
        .card-title {
            font-size: 1.4rem;
            font-weight: 700;
            color: var(--primary);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .card-icon {
            font-size: 1.8rem;
            color: var(--primary);
            background: var(--primary-light);
            width: 40px;
            height: 40px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .bridge-visual {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 30px 0;
            padding: 25px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: var(--border-radius);
            position: relative;
            overflow: hidden;
        }
        
        .bridge-visual::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, rgba(124, 58, 237, 0.1), transparent);
            z-index: 0;
        }
        
        .chain {
            text-align: center;
            padding: 20px;
            flex: 1;
            z-index: 1;
            transition: var(--transition);
        }
        
        .chain:hover {
            transform: scale(1.05);
        }
        
        .chain-icon {
            font-size: 3.5rem;
            margin-bottom: 15px;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 15px;
        }
        
        .bitcoin-icon {
            background: rgba(247, 147, 26, 0.2);
            color: var(--bitcoin);
        }
        
        .starknet-icon {
            background: rgba(124, 58, 237, 0.2);
            color: var(--starknet);
        }
        
        .bridge-arrow {
            font-size: 2.5rem;
            color: var(--primary);
            padding: 0 20px;
            z-index: 1;
            animation: pulse 2s infinite;
        }
        
        .bridge-form {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .form-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .form-group label {
            font-weight: 600;
            color: var(--primary);
            font-size: 0.95rem;
        }
        
        .form-group input, .form-group select {
            padding: 14px 16px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(0, 0, 0, 0.3);
            color: white;
            font-size: 1rem;
            transition: var(--transition);
        }

        .address-input-container {
            position: relative;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .address-input-actions {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }

        .btn-use-connected, .btn-paste {
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition);
            border: none;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .btn-use-connected {
            background: rgba(124, 58, 237, 0.2);
            color: var(--primary);
        }

        .btn-use-connected:hover {
            background: rgba(124, 58, 237, 0.3);
            transform: translateY(-1px);
        }

        .btn-paste {
            background: rgba(16, 185, 129, 0.2);
            color: var(--secondary);
        }

        .btn-paste:hover {
            background: rgba(16, 185, 129, 0.3);
            transform: translateY(-1px);
        }

        .address-info {
            margin-top: 8px;
            min-height: 20px;
        }

        .address-hint {
            color: var(--gray);
            font-size: 0.85rem;
            display: block;
            margin-bottom: 5px;
        }

        .address-validation {
            font-size: 0.8rem;
            font-weight: 500;
        }

        .validation-valid {
            color: var(--secondary);
        }

        .validation-invalid {
            color: var(--danger);
        }

        .validation-loading {
            color: var(--warning);
        }

        .service-status {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid var(--lighter);
            transition: var(--transition);
        }
        
        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 2px rgba(124, 58, 237, 0.2);
        }
        
        .amount-input {
            position: relative;
        }
        
        .amount-input input {
            padding-left: 50px;
        }
        
        .currency-symbol {
            position: absolute;
            left: 15px;
            top: 50%;
            transform: translateY(-50%);
            font-weight: 600;
            color: var(--primary);
            font-size: 1.2rem;
        }
        
        .balance-info {
            font-size: 0.9rem;
            color: var(--gray);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .max-btn {
            background: rgba(124, 58, 237, 0.2);
            border: none;
            color: var(--primary);
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 600;
            transition: var(--transition);
        }
        
        .max-btn:hover {
            background: rgba(124, 58, 237, 0.3);
            transform: translateY(-1px);
        }
        
        .network-selector {
            display: flex;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            padding: 6px;
            margin-bottom: 20px;
            gap: 5px;
        }

        .network-switcher {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 20px;
            border: 1px solid rgba(124, 58, 237, 0.1);
        }

        .network-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .network-name {
            font-weight: 600;
            color: var(--primary);
        }

        .network-badge {
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .mainnet-badge {
            background: rgba(16, 185, 129, 0.2);
            color: var(--secondary);
        }

        .testnet-badge {
            background: rgba(245, 158, 11, 0.2);
            color: var(--warning);
        }

        .network-warning {
            padding: 8px 12px;
            background: rgba(245, 158, 11, 0.1);
            border: 1px solid rgba(245, 158, 11, 0.3);
            border-radius: 8px;
            color: var(--warning);
            font-size: 0.85rem;
            margin-bottom: 15px;
        }

        .switch-network-btn {
            background: rgba(124, 58, 237, 0.2);
            border: 1px solid var(--primary);
            color: var(--primary);
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            transition: var(--transition);
        }

        .switch-network-btn:hover {
            background: rgba(124, 58, 237, 0.3);
            transform: translateY(-1px);
        }
        
        .network-option {
            flex: 1;
            padding: 12px;
            text-align: center;
            border-radius: 10px;
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }
        
        .network-option.active {
            background: var(--primary-light);
        }
        
        .fee-info {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .fee-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        .fee-item:last-child {
            border-bottom: none;
        }
        
        .fee-total {
            font-weight: 700;
            color: var(--primary);
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .btn {
            padding: 16px 28px;
            border-radius: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
            border: none;
            font-size: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            position: relative;
            overflow: hidden;
        }
        
        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: 0.5s;
        }
        
        .btn:hover::before {
            left: 100%;
        }
        
        .btn-primary {
            background: linear-gradient(to right, var(--primary), var(--primary-dark));
            color: white;
        }
        
        .btn-outline {
            background: transparent;
            border: 2px solid var(--primary);
            color: var(--primary);
        }
        
        .btn:disabled {
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.3);
            cursor: not-allowed;
        }
        
        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(124, 58, 237, 0.4);
        }

        .btn.connected {
            background: linear-gradient(to right, #4caf50, #45a049);
            cursor: default;
        }

        .btn.connected:hover {
            transform: none;
            box-shadow: 0 4px 6px rgba(76, 175, 80, 0.25);
        }

        .wallet-option.available {
            border-color: #7c3aed;
            background: rgba(124, 58, 237, 0.05);
        }

        .wallet-option.unavailable {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .wallet-option:hover {
            background: rgba(124, 58, 237, 0.1);
            border-color: #7c3aed;
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(124, 58, 237, 0.15);
        }

        .wallet-option:hover .wallet-icon {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
        }

        .wallet-icon {
            transition: var(--transition);
        }

        .manual-address-section h4 {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .manual-address-section input {
            transition: var(--transition);
        }

        .manual-address-section input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 2px rgba(124, 58, 237, 0.2);
        }

        .wallet-info {
            flex: 1;
        }

        .wallet-name {
            font-weight: 600;
            color: white;
            margin-bottom: 2px;
        }

        .wallet-type {
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.7);
        }

        .wallet-status {
            font-size: 0.8rem;
            color: #7c3aed;
            font-weight: 500;
        }

        /* Transaction Hash Copy Styles */
        .transaction-hash-container {
            display: flex;
            align-items: center;
            gap: 8px;
            width: 100%;
        }

        .transaction-hash {
            flex: 1;
            cursor: pointer;
            transition: var(--transition);
            padding: 4px 8px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.05);
        }

        .transaction-hash:hover {
            background: rgba(124, 58, 237, 0.1);
            color: var(--primary-light);
        }

        .copy-hash-btn {
            background: rgba(124, 58, 237, 0.2);
            border: none;
            color: var(--primary);
            padding: 6px 8px;
            border-radius: 4px;
            cursor: pointer;
            transition: var(--transition);
            font-size: 0.8rem;
            min-width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .copy-hash-btn:hover {
            background: rgba(124, 58, 237, 0.3);
            transform: scale(1.05);
        }

        .copy-hash-btn.copied {
            background: var(--secondary);
            color: white;
        }

        .copy-hash-btn.copied i::before {
            content: "\f00c"; /* Check mark icon */
        }

        /* Mini copy buttons for transaction list */
        .transaction-hash-mini {
            font-family: monospace;
            font-size: 0.7rem;
            cursor: pointer;
            transition: var(--transition);
            padding: 2px 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.05);
            display: inline-block;
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .transaction-hash-mini:hover {
            background: rgba(124, 58, 237, 0.1);
            color: var(--primary-light);
        }

        .copy-hash-btn-mini {
            background: rgba(124, 58, 237, 0.2);
            border: none;
            color: var(--primary);
            padding: 3px 6px;
            border-radius: 3px;
            cursor: pointer;
            transition: var(--transition);
            font-size: 0.7rem;
            min-width: 24px;
            height: 24px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            margin-left: 8px;
        }

        .copy-hash-btn-mini:hover {
            background: rgba(124, 58, 237, 0.3);
            transform: scale(1.05);
        }

        .copy-hash-btn-mini.copied {
            background: var(--secondary);
            color: white;
        }

        .copy-hash-btn-mini.copied i::before {
            content: "\f00c"; /* Check mark icon */
        }

        /* Wallet Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: linear-gradient(135deg, #0f172a, #1e293b);
            border-radius: var(--border-radius);
            padding: 30px;
            width: 100%;
            max-width: 450px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.05);
            position: relative;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .modal-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--primary);
        }

        .close-modal {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            font-size: 1.5rem;
            cursor: pointer;
            transition: var(--transition);
        }

        .close-modal:hover {
            color: white;
        }

        .wallet-options {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .wallet-option {
             display: flex;
             align-items: center;
             justify-content: space-between;
             gap: 15px;
             padding: 16px;
             background: rgba(30, 41, 59, 0.6);
             border-radius: 12px;
             border: 1px solid rgba(255, 255, 255, 0.05);
             transition: var(--transition);
             margin-bottom: 10px;
         }

        .btn.connected {
            background: linear-gradient(to right, #4caf50, #45a049);
            cursor: default;
            position: relative;
        }

        .btn.connected:hover {
            transform: none;
            box-shadow: 0 4px 6px rgba(76, 175, 80, 0.25);
        }

        .disconnect-btn {
            margin-left: 10px;
            padding: 4px 8px;
            background: rgba(239, 68, 68, 0.2);
            border-radius: 50%;
            cursor: pointer;
            transition: var(--transition);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 20px;
            font-size: 0.8rem;
        }

        .disconnect-btn:hover {
            background: rgba(239, 68, 68, 0.4);
            transform: scale(1.1);
        }

        .wallet-address {
            margin: 0 8px;
        }

        .wallet-disconnect {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(255, 255, 255, 0.2);
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            cursor: pointer;
            transition: var(--transition);
        }

        .wallet-disconnect:hover {
             background: rgba(239, 68, 68, 0.3);
             color: #ef4444;
         }

         .wallet-action {
             display: flex;
             align-items: center;
         }

         .wallet-action .btn {
             font-size: 0.85rem;
             padding: 8px 12px;
         }

         .wallet-name {
             font-weight: 600;
             color: white;
             flex: 1;
         }

        
        .transaction-status {
            margin-top: 30px;
        }
        
        .status-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
        
        .status-confirmed {
            background: var(--secondary);
        }
        
        .status-pending {
            background: var(--warning);
        }
        
        .status-processing {
            background: var(--primary);
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .progress-container {
            margin: 20px 0;
        }
        
        .progress-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 0.95rem;
            color: var(--gray);
        }
        
        .progress-bar {
            height: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            border-radius: 5px;
            background: linear-gradient(to right, var(--primary), var(--primary-light));
            width: 0%;
            transition: width 1s ease-in-out;
            position: relative;
            overflow: hidden;
        }
        
        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background-image: linear-gradient(
                -45deg, 
                rgba(255, 255, 255, 0.2) 25%, 
                transparent 25%, 
                transparent 50%, 
                rgba(255, 255, 255, 0.2) 50%, 
                rgba(255, 255, 255, 0.2) 75%, 
                transparent 75%, 
                transparent
            );
            z-index: 1;
            background-size: 20px 20px;
            animation: move 1s linear infinite;
            border-top-right-radius: 8px;
            border-bottom-right-radius: 8px;
        }
        
        @keyframes move {
            0% { background-position: 0 0; }
            100% { background-position: 20px 0; }
        }
        
        .recent-transactions {
            margin-top: 50px;
        }
        
        .section-title {
            font-size: 1.5rem;
            margin-bottom: 20px;
            color: var(--primary);
            font-weight: 600;
        }
        
        .transaction-list {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .transaction-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 18px;
            background: rgba(15, 23, 42, 0.5);
            border-radius: 12px;
            border-left: 4px solid var(--primary);
            transition: var(--transition);
        }
        
        .transaction-item:hover {
            background: rgba(15, 23, 42, 0.7);
            transform: translateX(5px);
        }
        
        .transaction-info {
            flex: 1;
        }
        
        .transaction-amount {
            font-weight: 700;
            margin-bottom: 5px;
            font-size: 1.1rem;
        }
        
        .transaction-details {
            font-size: 0.85rem;
            color: var(--gray);
        }
        
        .transaction-status-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
        }
        
        .status-completed {
            background: rgba(16, 185, 129, 0.2);
            color: var(--secondary);
        }
        
        .status-pending {
            background: rgba(245, 158, 11, 0.2);
            color: var(--warning);
        }
        
        .status-processing {
            background: rgba(124, 58, 237, 0.2);
            color: var(--primary);
        }
        
        .notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 15px 25px;
            background: rgba(15, 23, 42, 0.9);
            backdrop-filter: blur(10px);
            border-left: 4px solid var(--primary);
            border-radius: 8px;
            display: none;
            animation: slideIn 0.3s forwards;
            z-index: 1000;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            max-width: 400px;
        }
        
        @keyframes slideIn {
            from { transform: translateX(100px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        footer {
            margin-top: auto;
            text-align: center;
            padding: 30px 0;
            color: var(--gray);
            font-size: 0.9rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        /* Staking Styles */
        .staking-info {
            text-align: center;
        }

        .staking-stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
            gap: 15px;
        }

        .staking-stat {
            flex: 1;
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            border: 1px solid rgba(124, 58, 237, 0.1);
        }

        .staking-stat .stat-value {
            font-size: 1.4rem;
            font-weight: 700;
            margin-bottom: 5px;
            background: linear-gradient(to right, var(--primary), var(--primary-light));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .staking-stat .stat-label {
            font-size: 0.85rem;
            color: var(--gray);
        }

        .staking-actions {
            display: flex;
            gap: 10px;
        }

        .staking-actions .btn {
            flex: 1;
            padding: 12px;
            font-size: 0.9rem;
        }
        
        .stat-card {
            background: rgba(15, 23, 42, 0.7);
            backdrop-filter: blur(10px);
            border-radius: var(--border-radius);
            padding: 20px;
            border: 1px solid rgba(124, 58, 237, 0.1);
            transition: var(--transition);
            text-align: center;
        }
        
        .stat-card:hover {
            transform: translateY(-3px);
            border-color: rgba(124, 58, 237, 0.3);
        }
        
        .stat-value {
            font-size: 1.8rem;
            font-weight: 700;
            margin-bottom: 5px;
            background: linear-gradient(to right, var(--primary), var(--primary-light));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .stat-label {
            font-size: 0.9rem;
            color: var(--gray);
        }
        
        @media (max-width: 768px) {
            nav ul {
                gap: 15px;
                flex-wrap: wrap;
                justify-content: center;
            }

            header {
                flex-direction: column;
                gap: 20px;
            }

            .wallet-buttons {
                flex-wrap: wrap;
                justify-content: center;
            }

            .wallet-buttons .btn {
                font-size: 0.8rem;
                padding: 6px 12px;
            }

            .disconnect-btn {
                margin-left: 8px;
                width: 18px;
                height: 18px;
                font-size: 0.7rem;
            }

            .network-selector {
                flex-direction: column;
            }

            .bridge-visual {
                flex-direction: column;
                gap: 20px;
            }

            .bridge-card {
                padding: 20px;
            }

            .dashboard-title {
                font-size: 2rem;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }

            .address-input-actions {
                flex-direction: column;
                gap: 8px;
            }

            .btn-use-connected, .btn-paste {
                justify-content: center;
                padding: 10px 12px;
            }

            .wallet-disconnect {
                position: static;
                margin-left: 8px;
                width: 16px;
                height: 16px;
                font-size: 0.7rem;
            }

            .wallet-address {
                margin: 0 4px 0 0;
            }
        }
    </style>
</head>
<body>
    <div class="animated-bg"></div>
    <div class="glow glow-1"></div>
    <div class="glow glow-2"></div>
    
    <div class="container">
        <header>
            <div class="logo">
                <div class="logo-icon"><i class="fa-solid fa-bridge"></i></div>
                <div class="logo-text">Bitcoin-Starknet Bridge</div>
            </div>

            <nav>
                <ul>
                    <li><a href="../Bitcoin/Blocks.html">Dashboard</a></li>
                    <li><a href="../Wallet/Send.html">Send</a></li>
                    <li><a href="../Wallet/Receive.html">Receive</a></li>
                    <li><a href="#" class="active">Bridge</a></li>
                    <li><a href="../Wallet/History.html">History</a></li>
                </ul>
            </nav>

            <div class="wallet-buttons">
                <!-- Xverse Wallet Button -->
                <button type="button" class="btn btn-outline" id="connectXverseBtn" style="font-size: 0.85rem; padding: 8px 16px; border-color: #f7931a; color: #f7931a; background: rgba(247, 147, 26, 0.1); margin-right: 10px;">
                    <i class="fas fa-bitcoin" style="color: #f7931a;"></i> Xverse
                </button>

                <!-- Ready Wallet Button -->
                <button type="button" class="btn btn-outline" id="connectReadyBtn" style="font-size: 0.85rem; padding: 8px 16px; border-color: var(--primary); color: var(--primary); background: rgba(124, 58, 237, 0.1); margin-right: 10px;">
                    <i class="fas fa-link" style="color: var(--primary);"></i> Ready
                </button>

                <!-- Braavos Wallet Button -->
                <!-- <button type="button" class="btn btn-outline" id="connectBraavosBtn" style="font-size: 0.85rem; padding: 8px 16px; border-color: var(--primary); color: var(--primary); background: rgba(124, 58, 237, 0.1); margin-right: 10px;">
                    <i class="fas fa-shield-alt" style="color: var(--primary);"></i> Braavos
                </button> -->
            </div>
        </header>
        
        <h1 class="dashboard-title">Bridge Assets</h1>
        <p class="subtitle">Securely transfer assets between Bitcoin and Starknet networks with our trustless bridge protocol</p>


        <!-- Network Warning (shown only for testnet) -->
        <div class="network-warning" id="networkWarning" style="display: none;">
            <i class="fas fa-exclamation-triangle"></i>
            <span id="networkWarningText"></span>
        </div>
        
        <!-- Stats Grid -->
        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-value">$12.5M</div>
                <div class="stat-label">Total Value Bridged</div>
            </div>
            <div class="stat-card">
                <div class="stat-value">2,847</div>
                <div class="stat-label">Total Transactions</div>
            </div>
            <div class="stat-card">
                <div class="stat-value">15-25 min</div>
                <div class="stat-label">Average Bridge Time</div>
            </div>
            <div class="stat-card">
                <div class="stat-value">100%</div>
                <div class="stat-label">Security Audit Passed</div>
            </div>
        </div>
        
        <div class="bridge-container">
            <div class="bridge-card">
                <div class="card-header">
                    <h2 class="card-title"><i class="fa-solid fa-arrow-right-arrow-left"></i> Bridge Transfer</h2>
                    <div class="card-icon">
                        <i class="fa-solid fa-bridge"></i>
                        <div class="service-status" id="serviceStatus" style="position: absolute; top: -5px; right: -5px; width: 12px; height: 12px; border-radius: 50%; background: #ef4444;"></div>
                    </div>
                </div>
                
                <div class="network-selector">
                    <div class="network-option active" data-direction="to-starknet">
                        <i class="fab fa-bitcoin bitcoin"></i> → <i class="fa-solid fa-link starknet"></i>
                        <div>Bitcoin to Starknet</div>
                    </div>
                    <div class="network-option" data-direction="to-bitcoin">
                        <i class="fa-solid fa-link starknet"></i> → <i class="fab fa-bitcoin bitcoin"></i>
                        <div>Starknet to Bitcoin</div>
                    </div>
                </div>
                
                <div class="bridge-visual">
                    <div class="chain">
                        <div class="chain-icon bitcoin-icon"><i class="fab fa-bitcoin"></i></div>
                        <h3>Bitcoin</h3>
                        <p>Mainnet</p>
                        <small style="color: var(--gray); font-size: 0.8rem; margin-top: 5px; display: block;">
                            Connect: Trust Wallet, Coinbase, Phantom
                        </small>
                    </div>

                    <div class="bridge-arrow">
                        <i class="fa-solid fa-arrow-right"></i>
                    </div>

                    <div class="chain">
                        <div class="chain-icon starknet-icon"><i class="fa-solid fa-link"></i></div>
                        <h3>Starknet</h3>
                        <p>Layer 2</p>
                        <small style="color: var(--gray); font-size: 0.8rem; margin-top: 5px; display: block;">
                            Connect: Ready Wallet, Argent X, Braavos
                        </small>
                    </div>
                </div>

                
                <form class="bridge-form" id="bridgeForm">
                    <div class="form-group">
                        <label for="fromAddress">From Address</label>
                        <div class="address-input-container">
                            <input type="text" id="fromAddress" placeholder="Enter your wallet address or select from connected wallet" autocomplete="off">
                            <div class="address-input-actions">
                                <button type="button" class="btn-use-connected" id="useConnectedAddress" title="Use connected wallet address">
                                    <i class="fas fa-wallet"></i> Use Connected
                                </button>
                                <button type="button" class="btn-paste" id="pasteAddress" title="Paste from clipboard">
                                    <i class="fas fa-paste"></i> Paste
                                </button>
                            </div>
                        </div>
                        <div class="address-info">
                            <small class="address-hint" id="addressHint">
                                Enter a valid Bitcoin address for Bitcoin→Starknet transfers
                            </small>
                            <div class="address-validation" id="addressValidation"></div>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label for="toAddress">To Address</label>
                        <div class="address-input-container">
                            <input type="text" id="toAddress" placeholder="Enter your Starknet address or use connected wallet" autocomplete="off">
                            <div class="address-input-actions">
                                <button type="button" class="btn-use-connected" id="useConnectedToAddress" title="Use connected wallet address">
                                    <i class="fas fa-wallet"></i> Use Connected
                                </button>
                                <button type="button" class="btn-paste" id="pasteToAddress" title="Paste from clipboard">
                                    <i class="fas fa-paste"></i> Paste
                                </button>
                            </div>
                        </div>
                        <div class="address-info">
                            <small class="address-hint" id="toAddressHint">
                                Enter a valid StarkNet address for Bitcoin→Starknet transfers
                            </small>
                            <div class="address-validation" id="toAddressValidation"></div>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label for="bridgeAmount">Amount</label>
                        <div class="amount-input">
                            <span class="currency-symbol">₿</span>
                            <input type="number" id="bridgeAmount" placeholder="0.00" step="0.000001" min="0.001" required>
                        </div>
                        
                        <div class="balance-info">
                            <span>Balance: 1.2543 BTC</span>
                            <button type="button" class="max-btn">MAX</button>
                        </div>
                    </div>
                    
                    <div class="fee-info">
                        <div class="fee-item">
                            <span>Network Fee:</span>
                            <span>0.00015 BTC</span>
                        </div>
                        <div class="fee-item">
                            <span>Bridge Fee:</span>
                            <span>0.0005 BTC</span>
                        </div>
                        <div class="fee-item fee-total">
                            <span>Total Fee:</span>
                            <span>0.00065 BTC</span>
                        </div>
                    </div>
                    
                    <div style="display: flex; gap: 10px;">
                        <button type="submit" class="btn btn-primary" id="bridgeButton" style="flex: 1;">
                            <i class="fas fa-bridge"></i> Bridge Now
                        </button>
                        <button type="button" class="btn btn-outline" id="cancelBridgeBtn" onclick="cancelCurrentTransaction()" style="display: none;">
                            <i class="fas fa-times"></i> Cancel
                        </button>
                    </div>
                </form>
            </div>
            
            <div class="bridge-card">
                <div class="card-header">
                    <h2 class="card-title"><i class="fa-solid fa-hourglass-half"></i> Transaction Status</h2>
                    <div class="card-icon"><i class="fa-solid fa-clock"></i></div>
                </div>
                
                <div class="transaction-status">
                    <div class="status-header">
                        <h3>Current Transfer</h3>
                        <div class="status-indicator">
                            <div class="status-dot status-processing"></div>
                            <span>Processing</span>
                        </div>
                    </div>
                    
                    <div class="progress-container">
                        <div class="progress-label">
                            <span>Bridge Progress</span>
                            <span id="progressValue">45%</span>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="progressFill" style="width: 45%"></div>
                        </div>
                    </div>
                    
                    <div class="fee-info">
                        <div class="fee-item">
                            <span>Transaction ID:</span>
                            <div class="transaction-hash-container">
                                <span class="transaction-hash" style="font-family: monospace; font-size: 0.8rem;" onclick="copyTransactionHash(this)">0x8a34f7d0d2c5e1b9a3c8f7a6b5d4e3f2a1b0c9d8e7f6a5b4c3d2e1f0a9b8c7d6e5</span>
                                <button class="copy-hash-btn" onclick="copyTransactionHash(this.previousElementSibling)" title="Copy transaction hash">
                                    <i class="fas fa-copy"></i>
                                </button>
                            </div>
                        </div>
                        <div class="fee-item">
                            <span>Amount:</span>
                            <span>0.10000 BTC</span>
                        </div>
                        <div class="fee-item">
                            <span>Estimated Time:</span>
                            <span>15-25 minutes</span>
                        </div>
                    </div>
                    
                    <button class="btn btn-outline" style="margin-top: 15px;">
                        <i class="fas fa-external-link-alt"></i> View on Explorer
                    </button>
                </div>
            </div>

            <div class="bridge-card">
                <div class="card-header">
                    <h2 class="card-title"><i class="fa-solid fa-piggy-bank"></i> Staking Rewards</h2>
                    <div class="card-icon"><i class="fa-solid fa-coins"></i></div>
                </div>

                <div class="staking-info">
                    <div class="staking-stats">
                        <div class="staking-stat">
                            <div class="stat-value" id="stakedAmount">0.00</div>
                            <div class="stat-label">Staked Amount</div>
                        </div>
                        <div class="staking-stat">
                            <div class="stat-value" id="stakingRewards">0.00</div>
                            <div class="stat-label">Available Rewards</div>
                        </div>
                        <div class="staking-stat">
                            <div class="stat-value" id="stakingApy">12.5%</div>
                            <div class="stat-label">Current APY</div>
                        </div>
                    </div>

                    <div class="staking-actions" style="display: flex; gap: 10px; margin-top: 20px;">
                        <button class="btn btn-primary" id="stakeBtn" style="flex: 1;">
                            <i class="fas fa-plus"></i> Stake
                        </button>
                        <button class="btn btn-outline" id="unstakeBtn" style="flex: 1;">
                            <i class="fas fa-minus"></i> Unstake
                        </button>
                        <button class="btn btn-outline" id="claimRewardsBtn" style="flex: 1;">
                            <i class="fas fa-gift"></i> Claim Rewards
                        </button>
                    </div>
                </div>
            </div>
            
            <div class="recent-transactions">
                <h2 class="section-title">Recent Bridge Transactions</h2>
                
                <div class="transaction-list">
                    <div class="transaction-item">
                        <div class="transaction-info">
                            <div class="transaction-amount">+0.125 BTC</div>
                            <div class="transaction-details">
                                Bitcoin to Starknet • Oct 28, 2023 14:23
                                <div class="transaction-hash-container" style="margin-top: 5px;">
                                    <span class="transaction-hash-mini" onclick="copyTransactionHash(this)">0x7b2c8f1e4d9a6b3c5f8e2a1d4c7b9e6f3a5c8d1b4e7f2a9c6d3b8e5f1a4c7d9</span>
                                    <button class="copy-hash-btn-mini" onclick="copyTransactionHash(this.previousElementSibling)" title="Copy transaction hash">
                                        <i class="fas fa-copy"></i>
                                    </button>
                                </div>
                            </div>
                        </div>
                        <div class="transaction-status-badge status-completed">Completed</div>
                    </div>

                    <div class="transaction-item">
                        <div class="transaction-info">
                            <div class="transaction-amount">-0.500 BTC</div>
                            <div class="transaction-details">
                                Starknet to Bitcoin • Oct 27, 2023 09:47
                                <div class="transaction-hash-container" style="margin-top: 5px;">
                                    <span class="transaction-hash-mini" onclick="copyTransactionHash(this)">0x9f4e1c7b2a5d8f3e6c9b4a7d2e5f8a1c4b7d0e3f6a9c2d5b8e1f4a7c0d3</span>
                                    <button class="copy-hash-btn-mini" onclick="copyTransactionHash(this.previousElementSibling)" title="Copy transaction hash">
                                        <i class="fas fa-copy"></i>
                                    </button>
                                </div>
                            </div>
                        </div>
                        <div class="transaction-status-badge status-completed">Completed</div>
                    </div>

                    <div class="transaction-item">
                        <div class="transaction-info">
                            <div class="transaction-amount">+0.075 BTC</div>
                            <div class="transaction-details">
                                Bitcoin to Starknet • Oct 26, 2023 18:15
                                <div class="transaction-hash-container" style="margin-top: 5px;">
                                    <span class="transaction-hash-mini" onclick="copyTransactionHash(this)">0x5d8a2f4c1e7b9a3d6f8c5e2a4b7d1f9c6e3a8b5d0f2c7a9e4b1d6c8f3a5</span>
                                    <button class="copy-hash-btn-mini" onclick="copyTransactionHash(this.previousElementSibling)" title="Copy transaction hash">
                                        <i class="fas fa-copy"></i>
                                    </button>
                                </div>
                            </div>
                        </div>
                        <div class="transaction-status-badge status-processing">Processing</div>
                    </div>
                </div>
                
                <button class="btn btn-outline" style="margin-top: 20px; width: 100%;">
                    <i class="fas fa-history"></i> View All Transactions
                </button>
            </div>
        </div>
    </div>
    


    <!-- Notification -->
    <div class="notification" id="notification">
        <span id="notificationText"></span>
    </div>
    
    <footer>
        <p>© 2025 Bitcoin-Starknet Bridge. All rights reserved. | Security Audit Passed | v2.1.4</p>
        <p>Bridge processing time: 20-40 minutes | Network fees vary based on congestion</p>
    </footer>

    <!-- Starknet Bridge Integration -->
    <script src="../backend/src/services/starknet-bridge.js"></script>
    <script src="../backend/src/services/bridge-fallback.js"></script>
    <script src="../backend/src/services/contract-integration-test.js"></script>
    <script src="../backend/src/services/bitcoin-service.js"></script>
    <script src="../backend/src/utils/validation.js"></script>
    <script src="../backend/src/utils/ui.js"></script>
    <script src="../backend/src/utils/api.js"></script>
    <script src="../backend/src/app/bridge.js"></script>
    <script src="../backend/src/app/wallet.js"></script>
    <script src="../backend/src/contracts/Bridge.json"></script>
    <script src="../src/contracts/Bridge.cairo"></script>

    <script>
        // Bridge Configuration
        const BRIDGE_CONFIG = {
            // Contract addresses (UPDATED: Use Sepolia testnet contract addresses)
            BRIDGE_CONTRACT: '0x02a3a9bc77aa0733b3b3f911e6c14d986aeb1040c8968fc1b7ebac404b8ff347',
            SBTC_CONTRACT: '0x029a051888fb8d645e4f0279393e18f95b1eacdf47b87829dd997b6264588b2c',

            // Token configurations
            TOKENS: {
                SBTC: {
                    address: '0x07b10d8e5e60b2c9c5a5b12a4e1e5c4b3d2e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b',
                    decimals: 6,
                    symbol: 'SBTC'
                },
                STRK: {
                    address: '0x04718f5a0fc34cc1af16a1cdee98ffb20c31f5cd61d6ab07201858f4287c938d',
                    decimals: 18,
                    symbol: 'STRK'
                }
            },

            // Multi-Network Configuration with multiple RPC endpoints for reliability
            NETWORKS: {
                mainnet: {
                    name: 'Starknet Mainnet',
                    chainId: '0x534e5f4d41494e', // SN_MAIN
                    rpcUrls: [
                        'https://starknet-mainnet.public.blastapi.io/rpc/v0_7',
                        'https://starknet-mainnet.g.alchemy.com/v2/demo',
                        'https://rpc.starknet.lava.build',
                        'https://starknet.public.blastapi.io'
                    ],
                    explorerUrl: 'https://starkscan.co',
                    isTestnet: false,
                    warning: null,
                    // Contract addresses for mainnet
                    contracts: {
                        BRIDGE_CONTRACT: '0x02e2bbfd1134c728bd9d5ee12fd9d844b10fb634b8cc64f39c87a5048e43283e',
                        SBTC_CONTRACT: '0x029a051888fb8d645e4f0279393e18f95b1eacdf47b87829dd997b6264588b2c'
                    }
                },
                testnet: {
                    name: 'Starknet Sepolia Testnet',
                    chainId: '0x534e5f5345504f4c49', // SN_SEPOLIA
                    rpcUrls: [
                        'https://starknet-sepolia.public.blastapi.io/rpc/v0_7',
                        'https://starknet-sepolia.g.alchemy.com/v2/demo',
                        'https://rpc.starknet-sepolia.lava.build',
                        'https://starknet-sepolia.public.blastapi.io'
                    ],
                    explorerUrl: 'https://sepolia.starkscan.co',
                    isTestnet: true,
                    warning: '⚠️ TESTNET: This is a test network. Tokens have no real value.',
                    // Contract addresses for testnet (replace with actual deployed addresses)
                    contracts: {
                        BRIDGE_CONTRACT: '0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef', // Placeholder - replace with actual
                        SBTC_CONTRACT: '0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef' // Placeholder - replace with actual
                    }
                }
            },

            // Current network (default to mainnet)
            currentNetwork: 'mainnet',

            // Get current network configuration
            get NETWORK() {
                return this.NETWORKS[this.currentNetwork];
            },

            // Get current RPC URL for the network
            getCurrentRpcUrl: function() {
                const network = this.NETWORKS[this.currentNetwork];
                if (!network || !network.rpcUrls) {
                    throw new Error(`No RPC URLs configured for network: ${this.currentNetwork}`);
                }
                return network.rpcUrls[this.currentRpcIndex || 0];
            },

            // Switch to next RPC endpoint for the current network
            switchToNextRpc: function() {
                const network = this.NETWORKS[this.currentNetwork];
                if (!network || !network.rpcUrls || network.rpcUrls.length === 0) {
                    throw new Error(`No RPC URLs available for network: ${this.currentNetwork}`);
                }

                this.currentRpcIndex = (this.currentRpcIndex || 0) + 1;
                if (this.currentRpcIndex >= network.rpcUrls.length) {
                    this.currentRpcIndex = 0;
                }

                const newRpcUrl = this.getCurrentRpcUrl();
                console.log(`🔄 Switched to RPC endpoint: ${newRpcUrl}`);

                return newRpcUrl;
            },

            // Test RPC endpoint connectivity
            testRpcEndpoint: async function(rpcUrl) {
                const startTime = Date.now();
                try {
                    const response = await fetch(rpcUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            jsonrpc: '2.0',
                            method: 'starknet_blockNumber',
                            params: [],
                            id: 1
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const data = await response.json();

                    if (data.error) {
                        throw new Error(`RPC Error: ${data.error.message}`);
                    }

                    return {
                        success: true,
                        blockNumber: data.result,
                        latency: Date.now() - startTime
                    };
                } catch (error) {
                    return {
                        success: false,
                        error: error.message,
                        latency: Date.now() - startTime
                    };
                }
            },

            // Find the best available RPC endpoint
            findBestRpcEndpoint: async function() {
                const network = this.NETWORKS[this.currentNetwork];
                if (!network || !network.rpcUrls || network.rpcUrls.length === 0) {
                    throw new Error(`No RPC URLs configured for network: ${this.currentNetwork}`);
                }

                console.log(`🔍 Testing ${network.rpcUrls.length} RPC endpoints for ${network.name}...`);

                for (let i = 0; i < network.rpcUrls.length; i++) {
                    const rpcUrl = network.rpcUrls[i];
                    console.log(`Testing RPC ${i + 1}/${network.rpcUrls.length}: ${rpcUrl}`);

                    const result = await this.testRpcEndpoint(rpcUrl);

                    if (result.success) {
                        console.log(`✅ RPC endpoint ${i + 1} is working (latency: ${result.latency}ms)`);
                        this.currentRpcIndex = i;
                        return { rpcUrl, index: i };
                    } else {
                        console.log(`❌ RPC endpoint ${i + 1} failed: ${result.error}`);
                    }
                }

                // If no endpoint is working, throw error with details
                throw new Error(`All RPC endpoints failed for ${network.name}`);
            },

            // Switch network
            switchNetwork: function(network) {
                if (this.NETWORKS[network]) {
                    this.currentNetwork = network;
                    this.currentRpcIndex = 0; // Reset RPC index when switching networks
                    // Update contract addresses
                    this.BRIDGE_CONTRACT = this.NETWORKS[network].contracts.BRIDGE_CONTRACT;
                    this.SBTC_CONTRACT = this.NETWORKS[network].contracts.SBTC_CONTRACT;
                    return true;
                }
                return false;
            }
        };

        // Global bridge state
        let bridgeState = {
            isInitialized: false,
            isBridgePaused: false,
            stakingData: {
                stakedAmount: 0,
                rewards: 0,
                apy: 12.5
            },
            currentDirection: 'to-starknet',
            currentNetwork: 'mainnet'
        };

        // Current direction variable for easier access
        let currentDirection = bridgeState.currentDirection;

        // DOM Elements
        const notification = document.getElementById('notification');
        const notificationText = document.getElementById('notificationText');
        const bridgeForm = document.getElementById('bridgeForm');
        const bridgeAmount = document.getElementById('bridgeAmount');
        const fromAddressInput = document.getElementById('fromAddress');
        const toAddressInput = document.getElementById('toAddress');
        const addressValidation = document.getElementById('addressValidation');
        const toAddressValidation = document.getElementById('toAddressValidation');
        const addressHint = document.getElementById('addressHint');
        const toAddressHint = document.getElementById('toAddressHint');
        const progressFill = document.getElementById('progressFill');
        const progressValue = document.getElementById('progressValue');
        const stakedAmountEl = document.getElementById('stakedAmount');
        const stakingRewardsEl = document.getElementById('stakingRewards');
        const stakingApyEl = document.getElementById('stakingApy');
        const stakeBtn = document.getElementById('stakeBtn');
        const unstakeBtn = document.getElementById('unstakeBtn');
        const claimRewardsBtn = document.getElementById('claimRewardsBtn');
        const useConnectedAddressBtn = document.getElementById('useConnectedAddress');
        const pasteAddressBtn = document.getElementById('pasteAddress');
        const useConnectedToAddressBtn = document.getElementById('useConnectedToAddress');
        const pasteToAddressBtn = document.getElementById('pasteToAddress');
        const maxButton = document.querySelector('.max-btn');
        const networkOptions = document.querySelectorAll('.network-option');
        const bridgeButton = document.getElementById('bridgeButton');
        const cancelBridgeBtn = document.getElementById('cancelBridgeBtn');
        const connectStarknetBtn = document.getElementById('connectStarknetBtn');
        const starknetConnectSection = document.getElementById('starknetConnectSection');

        // New wallet connect buttons
        const connectXverseBtn = document.getElementById('connectXverseBtn');
        const connectReadyBtn = document.getElementById('connectReadyBtn');
        const connectBraavosBtn = document.getElementById('connectBraavosBtn');

        // Wallet connection state
        let connectedWallet = null;
        let connectedAddress = null;

        // Connect to Xverse wallet using Sats Connect
        async function connectToXverseWallet() {
            try {
                // Check if Sats Connect is available and has request method
                if (window.satsConnect && typeof window.satsConnect.request === 'function') {
                    console.log('🔄 Using Sats Connect for Xverse...');

                    const response = await window.satsConnect.request('getAddresses', {
                        purposes: ['ordinals', 'payment'],
                        message: 'Connect to Bitcoin-Starknet Bridge'
                    });

                    if (response && response.addresses && response.addresses.length > 0) {
                        const bitcoinAddress = response.addresses.find(addr => addr.purpose === 'payment')?.address ||
                                              response.addresses[0].address;

                        return {
                            address: bitcoinAddress,
                            name: 'Xverse Wallet',
                            provider: window.satsConnect,
                            type: 'bitcoin'
                        };
                    }
                }

                // Fallback to direct Xverse API
                if (window.xverse && typeof window.xverse.request === 'function') {
                    console.log('🔄 Using Xverse direct API...');

                    const result = await window.xverse.request('getAddresses', {
                        purposes: ['ordinals', 'payment']
                    });

                    if (result && result.addresses && result.addresses.length > 0) {
                        const bitcoinAddress = result.addresses.find(addr => addr.purpose === 'payment')?.address ||
                                              result.addresses[0].address;

                        return {
                            address: bitcoinAddress,
                            name: 'Xverse Wallet',
                            provider: window.xverse,
                            type: 'bitcoin'
                        };
                    }
                }

                // Fallback to Unisat
                if (window.unisat && typeof window.unisat.requestAccounts === 'function') {
                    console.log('🔄 Using Unisat wallet...');
                    const accounts = await window.unisat.requestAccounts();
                    if (accounts && accounts.length > 0) {
                        return {
                            address: accounts[0],
                            name: 'Unisat Wallet',
                            provider: window.unisat,
                            type: 'bitcoin'
                        };
                    }
                }

                // Final fallback: Check for any Bitcoin wallet
                if (window.bitcoin) {
                    console.log('🔄 Using generic Bitcoin wallet API...');
                    const accounts = await window.bitcoin.requestAccounts();
                    if (accounts && accounts.length > 0) {
                        return {
                            address: accounts[0],
                            name: 'Bitcoin Wallet',
                            provider: window.bitcoin,
                            type: 'bitcoin'
                        };
                    }
                }

                throw new Error('Xverse wallet not available. Please install Xverse extension.');

            } catch (error) {
                console.error('Xverse connection error:', error);
                throw error;
            }
        }

        // Connect to Ready wallet (Starknet) - Shows wallet popup for user to click connect
        async function connectToReadyWallet() {
            try {
                console.log('🔄 Opening Ready wallet popup...');

                if (!window.starknet) {
                    throw new Error('Ready wallet not detected. Please install Argent X, Braavos, or another Starknet wallet.');
                }

                // Enable the wallet (this triggers the wallet popup)
                await window.starknet.enable();

                if (!window.starknet.selectedAddress) {
                    throw new Error('No address selected in Ready wallet');
                }

                console.log('✅ Ready wallet connected successfully');
                return {
                    address: window.starknet.selectedAddress,
                    name: 'Ready Wallet',
                    provider: window.starknet,
                    type: 'starknet'
                };

            } catch (error) {
                console.error('Ready wallet connection error:', error);

                if (error.message.includes('rejected') || error.code === 4001) {
                    throw new Error('Wallet connection cancelled by user');
                }

                if (error.message.includes('not detected') || error.message.includes('not available')) {
                    throw new Error('Ready wallet not found. Please install Argent X, Braavos, or another Starknet wallet.');
                }

                throw error;
            }
        }

        // Connect to Braavos wallet (Starknet) - Shows wallet popup for user to click connect
        async function connectToBraavosWallet() {
            try {
                console.log('🔄 Opening Braavos wallet popup...');

                // Check if Braavos is available as the current Starknet wallet
                if (window.starknet) {
                    // Check if it's Braavos by examining wallet properties
                    const isBraavos = window.starknet.id === 'braavos' ||
                                      window.starknet.name?.toLowerCase().includes('braavos') ||
                                      window.starknet.constructor?.name?.includes('Braavos') ||
                                      window.starknet.constructor?.toString().toLowerCase().includes('braavos');

                    if (isBraavos) {
                        console.log('✅ Current Starknet wallet is Braavos');
                    } else {
                        console.log('⚠️ Current wallet is not Braavos, checking providers...');

                        // Try to find Braavos in providers array
                        if (window.starknet.providers && Array.isArray(window.starknet.providers)) {
                            const braavosProvider = window.starknet.providers.find(p =>
                                p.id === 'braavos' ||
                                p.name?.toLowerCase().includes('braavos') ||
                                p.constructor?.name?.includes('Braavos') ||
                                p.constructor?.toString().toLowerCase().includes('braavos')
                            );

                            if (braavosProvider) {
                                console.log('🔄 Switching to Braavos provider...');
                                window.starknet = braavosProvider;
                            } else {
                                console.log('❌ Braavos not found in providers array');
                            }
                        }
                    }

                    // Enable the wallet (this will show Braavos popup if it's the active wallet)
                    await window.starknet.enable();

                    if (!window.starknet.selectedAddress) {
                        throw new Error('No address selected in Braavos wallet');
                    }

                    console.log('✅ Braavos wallet connected successfully');
                    return {
                        address: window.starknet.selectedAddress,
                        name: 'Braavos Wallet',
                        provider: window.starknet,
                        type: 'starknet'
                    };
                }

                // Check for Braavos in ethereum providers as fallback
                if (window.ethereum && window.ethereum.providers) {
                    const braavosProvider = window.ethereum.providers.find(p =>
                        p.id === 'braavos' ||
                        p.name?.toLowerCase().includes('braavos') ||
                        p.isBraavos === true ||
                        p.constructor?.name?.includes('Braavos') ||
                        p.constructor?.toString().toLowerCase().includes('braavos')
                    );

                    if (braavosProvider) {
                        console.log('🔄 Found Braavos in ethereum providers...');
                        await braavosProvider.enable();

                        if (!braavosProvider.selectedAddress) {
                            throw new Error('No address selected in Braavos wallet');
                        }

                        return {
                            address: braavosProvider.selectedAddress,
                            name: 'Braavos Wallet',
                            provider: braavosProvider,
                            type: 'starknet'
                        };
                    }
                }

                // If no Starknet wallet found at all, provide helpful error
                throw new Error('Braavos wallet not detected. Please make sure Braavos is installed and set as your active Starknet wallet in the extension.');

            } catch (error) {
                console.error('Braavos wallet connection error:', error);

                if (error.message.includes('rejected') || error.code === 4001) {
                    throw new Error('Wallet connection cancelled by user');
                }

                if (error.message.includes('not detected') || error.message.includes('not available') || error.message.includes('not found')) {
                    throw new Error('Braavos wallet not found. Please install Braavos wallet extension and set it as your active Starknet wallet.');
                }

                throw error;
            }
        }

        // Connect to Xverse Wallet (Bitcoin)
        async function connectToXverseWallet() {
            try {
                if (!window.xverse && !window.satsConnect && !window.ethereum?.isXverse) {
                    throw new Error('Xverse wallet not detected. Please install Xverse wallet extension.');
                }

                if (typeof window.xverse?.enable !== 'function' && typeof window.satsConnect?.request !== 'function' && typeof window.ethereum?.request !== 'function') {
                    throw new Error('Xverse wallet does not support connection. Please update your wallet.');
                }

                console.log('🔄 Connecting to Xverse wallet...');

                // Try different Xverse connection methods
                let address;

                // Method 1: Direct Xverse API
                if (window.xverse && typeof window.xverse.enable === 'function') {
                    await window.xverse.enable();
                    if (window.xverse.selectedAddress) {
                        address = window.xverse.selectedAddress;
                    }
                }

                // Method 2: Sats Connect API
                if (!address && window.satsConnect && typeof window.satsConnect.request === 'function') {
                    const response = await window.satsConnect.request('getAddresses', {
                        purposes: ['ordinals', 'payment'],
                        message: 'Connect to VernWallet Bridge'
                    });
                    if (response && response.addresses && response.addresses.length > 0) {
                        address = response.addresses.find(addr => addr.purpose === 'payment')?.address ||
                                  response.addresses[0].address;
                    }
                }

                // Method 3: Ethereum-style connection (Xverse can work with Ethereum API)
                if (!address && window.ethereum && window.ethereum.isXverse) {
                    const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                    if (accounts && accounts.length > 0) {
                        address = accounts[0];
                    }
                }

                if (!address) {
                    throw new Error('No Xverse address selected');
                }

                return {
                    address: address,
                    name: 'Xverse Wallet',
                    provider: window.xverse || window.satsConnect || window.ethereum,
                    type: 'bitcoin'
                };

            } catch (error) {
                console.error('Xverse wallet connection error:', error);

                if (error.message.includes('rejected') || error.code === 4001) {
                    throw new Error('Wallet connection rejected by user');
                }

                throw error;
            }
        }

        // Connect to Xverse Wallet (Bitcoin) - Shows wallet popup for user to click connect
        async function connectToXverseWallet() {
            try {
                console.log('🔄 Opening Xverse wallet popup...');

                // Check if Xverse is available - be more permissive
                if (!window.xverse && !window.satsConnect && !window.ethereum?.isXverse && !window.ethereum) {
                    throw new Error('Xverse wallet not detected. Please install Xverse wallet extension.');
                }

                let address;

                // Method 1: Sats Connect API (preferred for Xverse - shows popup)
                if (window.satsConnect && typeof window.satsConnect.request === 'function') {
                    console.log('🔄 Using Sats Connect for Xverse (popup)...');
                    try {
                        const response = await window.satsConnect.request('getAddresses', {
                            purposes: ['ordinals', 'payment'],
                            message: 'Connect to VernWallet Bridge'
                        });

                        if (response && response.addresses && response.addresses.length > 0) {
                            address = response.addresses.find(addr => addr.purpose === 'payment')?.address ||
                                      response.addresses[0].address;
                            console.log('✅ Got address from Sats Connect:', address);
                        }
                    } catch (satsError) {
                        console.log('⚠️ Sats Connect failed:', satsError.message);
                    }
                }

                // Method 2: Direct Xverse API (shows popup)
                if (!address && window.xverse && typeof window.xverse.request === 'function') {
                    console.log('🔄 Using Xverse direct API (popup)...');
                    try {
                        const result = await window.xverse.request('getAddresses', {
                            purposes: ['ordinals', 'payment']
                        });

                        if (result && result.addresses && result.addresses.length > 0) {
                            address = result.addresses.find(addr => addr.purpose === 'payment')?.address ||
                                      result.addresses[0].address;
                            console.log('✅ Got address from Xverse direct API:', address);
                        }
                    } catch (xverseError) {
                        console.log('⚠️ Xverse direct API failed:', xverseError.message);
                    }
                }

                // Method 3: Unisat (Xverse can work with Unisat API)
                if (!address && window.unisat && typeof window.unisat.requestAccounts === 'function') {
                    console.log('🔄 Using Unisat wallet (popup)...');
                    try {
                        const accounts = await window.unisat.requestAccounts();
                        if (accounts && accounts.length > 0) {
                            address = accounts[0];
                            console.log('✅ Got address from Unisat:', address);
                        }
                    } catch (unisatError) {
                        console.log('⚠️ Unisat failed:', unisatError.message);
                    }
                }

                // Method 4: Generic Bitcoin wallet API
                if (!address && window.bitcoin && typeof window.bitcoin.requestAccounts === 'function') {
                    console.log('🔄 Using generic Bitcoin wallet API (popup)...');
                    try {
                        const accounts = await window.bitcoin.requestAccounts();
                        if (accounts && accounts.length > 0) {
                            address = accounts[0];
                            console.log('✅ Got address from generic Bitcoin API:', address);
                        }
                    } catch (bitcoinError) {
                        console.log('⚠️ Generic Bitcoin API failed:', bitcoinError.message);
                    }
                }

                // Method 5: Fallback to Ethereum API (some Xverse versions work with this)
                if (!address && window.ethereum && typeof window.ethereum.request === 'function') {
                    console.log('🔄 Using Ethereum API fallback (popup)...');
                    try {
                        const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                        if (accounts && accounts.length > 0) {
                            address = accounts[0];
                            console.log('✅ Got address from Ethereum API:', address);
                        }
                    } catch (ethError) {
                        console.log('⚠️ Ethereum API failed:', ethError.message);
                    }
                }

                if (!address) {
                    console.error('❌ No address obtained from any Xverse connection method');
                    throw new Error('Could not connect to Xverse wallet. Please ensure Xverse is installed and try again.');
                }

                console.log('✅ Xverse wallet connected successfully with address:', address);
                return {
                    address: address,
                    name: 'Xverse Wallet',
                    provider: window.xverse || window.satsConnect || window.unisat || window.bitcoin || window.ethereum,
                    type: 'bitcoin'
                };

            } catch (error) {
                console.error('Xverse wallet connection error:', error);

                if (error.message.includes('rejected') || error.code === 4001) {
                    throw new Error('Wallet connection cancelled by user');
                }

                if (error.message.includes('not detected') || error.message.includes('not available')) {
                    throw new Error('Xverse wallet not found. Please install the Xverse extension.');
                }

                throw error;
            }
        }

        // Update wallet buttons to show connected addresses
        function updateWalletUI() {
            if (connectedWallet && connectedAddress) {
                // Update Xverse button if connected to Xverse
                if (connectedWallet.includes('Xverse') && connectXverseBtn) {
                    connectXverseBtn.innerHTML = `
                        <i class="fas fa-bitcoin"></i>
                        <span style="font-size: 0.75rem; display: block; margin-top: 2px;">
                            ${connectedAddress.substring(0, 6)}...${connectedAddress.substring(connectedAddress.length - 4)}
                        </span>
                    `;
                    connectXverseBtn.classList.add('connected');
                    connectXverseBtn.style.background = 'linear-gradient(to right, #4caf50, #45a049)';
                    connectXverseBtn.style.borderColor = '#4caf50';
                }

                // Update Ready button if connected to Ready
                if (connectedWallet.includes('Ready') && connectReadyBtn) {
                    connectReadyBtn.innerHTML = `
                        <i class="fas fa-link"></i>
                        <span style="font-size: 0.75rem; display: block; margin-top: 2px;">
                            ${connectedAddress.substring(0, 6)}...${connectedAddress.substring(connectedAddress.length - 4)}
                        </span>
                    `;
                    connectReadyBtn.classList.add('connected');
                    connectReadyBtn.style.background = 'linear-gradient(to right, #4caf50, #45a049)';
                    connectReadyBtn.style.borderColor = '#4caf50';
                }

                // Update Braavos button if connected to Braavos
                if (connectedWallet.includes('Braavos') && connectBraavosBtn) {
                    connectBraavosBtn.innerHTML = `
                        <i class="fas fa-shield-alt"></i>
                        <span style="font-size: 0.75rem; display: block; margin-top: 2px;">
                            ${connectedAddress.substring(0, 6)}...${connectedAddress.substring(connectedAddress.length - 4)}
                        </span>
                    `;
                    connectBraavosBtn.classList.add('connected');
                    connectBraavosBtn.style.background = 'linear-gradient(to right, #4caf50, #45a049)';
                    connectBraavosBtn.style.borderColor = '#4caf50';
                }
            } else {
                // Reset buttons to default state
                if (connectXverseBtn) {
                    connectXverseBtn.innerHTML = '<i class="fas fa-bitcoin" style="color: #f7931a;"></i> Xverse';
                    connectXverseBtn.classList.remove('connected');
                    connectXverseBtn.style.background = 'rgba(247, 147, 26, 0.1)';
                    connectXverseBtn.style.borderColor = '#f7931a';
                }

                if (connectReadyBtn) {
                    connectReadyBtn.innerHTML = '<i class="fas fa-link" style="color: var(--primary);"></i> Ready';
                    connectReadyBtn.classList.remove('connected');
                    connectReadyBtn.style.background = 'rgba(124, 58, 237, 0.1)';
                    connectReadyBtn.style.borderColor = 'var(--primary)';
                }

                if (connectBraavosBtn) {
                    connectBraavosBtn.innerHTML = '<i class="fas fa-shield-alt" style="color: var(--primary);"></i> Braavos';
                    connectBraavosBtn.classList.remove('connected');
                    connectBraavosBtn.style.background = 'rgba(124, 58, 237, 0.1)';
                    connectBraavosBtn.style.borderColor = 'var(--primary)';
                }
            }
        }

        // Add event listeners for wallet buttons
        if (connectXverseBtn) {
            connectXverseBtn.addEventListener('click', async () => {
                try {
                    console.log('🔄 Connecting to Xverse wallet...');
                    const result = await connectToXverseWallet();
                    if (result) {
                        connectedWallet = result.name;
                        connectedAddress = result.address;
                        updateWalletUI();
                        showNotification(`✅ Connected to ${result.name}`);
                    }
                } catch (error) {
                    console.error('Xverse connection failed:', error);
                    showNotification(`❌ Xverse connection failed: ${error.message}`, true);
                }
            });
        }

        if (connectReadyBtn) {
            connectReadyBtn.addEventListener('click', async () => {
                try {
                    console.log('🔄 Connecting to Ready wallet...');
                    const result = await connectToReadyWallet();
                    if (result) {
                        connectedWallet = result.name;
                        connectedAddress = result.address;
                        updateWalletUI();
                        showNotification(`✅ Connected to ${result.name}`);
                    }
                } catch (error) {
                    console.error('Ready connection failed:', error);
                    showNotification(`❌ Ready connection failed: ${error.message}`, true);
                }
            });
        }

        if (connectBraavosBtn) {
            connectBraavosBtn.addEventListener('click', async () => {
                try {
                    console.log('🔄 Connecting to Braavos wallet...');
                    const result = await connectToBraavosWallet();
                    if (result) {
                        connectedWallet = result.name;
                        connectedAddress = result.address;
                        updateWalletUI();
                        showNotification(`✅ Connected to ${result.name}`);
                    }
                } catch (error) {
                    console.error('Braavos connection failed:', error);
                    showNotification(`❌ Braavos connection failed: ${error.message}`, true);
                }
            });
        }

        // Available wallets configuration - context-aware based on bridge direction
        const getAvailableWallets = () => {
            const bitcoinWallets = [
                {
                    id: 'xverse',
                    name: 'Xverse Wallet',
                    type: 'Bitcoin',
                    icon: 'fas fa-bitcoin',
                    isAvailable: () => {
                        try {
                            // Method 1: Check for Xverse wallet global object
                            if (typeof window !== 'undefined' && window.xverse) {
                                return true;
                            }

                            // Method 2: Check for Xverse in ethereum providers
                            if (window.ethereum) {
                                // Check if current provider is Xverse
                                if (window.ethereum.isXverse ||
                                    window.ethereum.constructor?.name?.includes('Xverse') ||
                                    window.ethereum.constructor?.toString().toLowerCase().includes('xverse')) {
                                    return true;
                                }

                                // Check providers array for Xverse
                                if (window.ethereum.providers && Array.isArray(window.ethereum.providers)) {
                                    const xverseProvider = window.ethereum.providers.find(p =>
                                        p.isXverse ||
                                        p.constructor?.name?.includes('Xverse') ||
                                        p.constructor?.toString().toLowerCase().includes('xverse')
                                    );
                                    if (xverseProvider) return true;
                                }
                            }

                            // Method 3: Check user agent for Xverse indicators
                            if (typeof navigator !== 'undefined') {
                                const userAgent = navigator.userAgent.toLowerCase();
                                if (userAgent.includes('xverse') ||
                                    userAgent.includes('xversewallet') ||
                                    userAgent.includes('xverse-bitcoin')) {
                                    return true;
                                }
                            }

                            // Method 4: Check for Xverse-specific wallet properties
                            if (typeof window !== 'undefined') {
                                // Check for common Xverse wallet properties
                                const xverseProps = ['xverse', 'Xverse', 'xverseWallet', 'XverseWallet'];
                                for (const prop of xverseProps) {
                                    if (window[prop] && (window[prop].isXverse || window[prop].isConnected)) {
                                        return true;
                                    }
                                }
                            }

                            // Method 5: Try to detect Xverse through wallet connection attempt
                            if (window.ethereum && typeof window.ethereum.request === 'function') {
                                // This is a fallback - if we have ethereum and can make requests, assume it might be Xverse
                                // This is less reliable but better than missing the wallet
                                return true;
                            }

                            return false;
                        } catch (error) {
                            console.warn('Error detecting Xverse wallet:', error);
                            return false;
                        }
                    },
                    connect: async () => {
                        const walletName = 'Xverse Wallet';

                        try {
                            // Check if Sats Connect is available (Xverse's Bitcoin wallet API)
                            if (window.satsConnect || window.XverseProviders?.BitcoinProvider) {
                                console.log('🔄 Connecting via Sats Connect (Xverse Bitcoin API)...');

                                // Use Sats Connect to request addresses
                                const response = await window.satsConnect.request('getAddresses', {
                                    purposes: ['ordinals', 'payment'],
                                    message: 'Connect to Bitcoin-Starknet Bridge'
                                });

                                if (response && response.addresses && response.addresses.length > 0) {
                                    const bitcoinAddress = response.addresses.find(addr => addr.purpose === 'payment')?.address ||
                                                          response.addresses[0].address;

                                    console.log('✅ Connected to Xverse via Sats Connect');
                                    return {
                                        address: bitcoinAddress,
                                        name: walletName,
                                        provider: window.satsConnect || window.XverseProviders.BitcoinProvider,
                                        type: 'bitcoin'
                                    };
                                }
                            }

                            // Fallback: Try Xverse's direct API
                            if (window.xverse && typeof window.xverse.request === 'function') {
                                console.log('🔄 Trying Xverse direct API...');

                                try {
                                    const result = await window.xverse.request('getAddresses', {
                                        purposes: ['ordinals', 'payment']
                                    });

                                    if (result && result.addresses && result.addresses.length > 0) {
                                        const bitcoinAddress = result.addresses.find(addr => addr.purpose === 'payment')?.address ||
                                                              result.addresses[0].address;

                                        console.log('✅ Connected via Xverse direct API');
                                        return {
                                            address: bitcoinAddress,
                                            name: walletName,
                                            provider: window.xverse,
                                            type: 'bitcoin'
                                        };
                                    }
                                } catch (directError) {
                                    console.log('⚠️ Xverse direct API failed, trying other methods');
                                }
                            }

                            // Fallback: Try Unisat or other Bitcoin wallet APIs
                            if (window.unisat) {
                                console.log('🔄 Trying Unisat wallet...');
                                const accounts = await window.unisat.requestAccounts();
                                if (accounts && accounts.length > 0) {
                                    console.log('✅ Connected via Unisat');
                                    return {
                                        address: accounts[0],
                                        name: 'Unisat Wallet',
                                        provider: window.unisat,
                                        type: 'bitcoin'
                                    };
                                }
                            }

                            // Final fallback: Ethereum-style connection (for compatibility)
                            if (window.ethereum) {
                                console.log('🔄 Trying Ethereum-style connection...');

                                let provider = window.ethereum;

                                // Check if it's Xverse in Ethereum mode
                                if (window.ethereum.isXverse) {
                                    provider = window.ethereum;
                                } else if (window.ethereum.providers) {
                                    const xverseProvider = window.ethereum.providers.find(p => p.isXverse);
                                    if (xverseProvider) {
                                        provider = xverseProvider;
                                    }
                                }

                                const accounts = await provider.request({ method: 'eth_requestAccounts' });

                                if (accounts && accounts.length > 0) {
                                    console.log('✅ Connected via Ethereum API (Xverse)');
                                    return {
                                        address: accounts[0],
                                        name: walletName,
                                        provider: provider,
                                        type: 'ethereum'
                                    };
                                }
                            }

                            throw new Error('Unable to connect to Xverse wallet. Please ensure Xverse is installed and try again.');

                        } catch (error) {
                            console.error('❌ Xverse wallet connection error:', error);

                            // Handle user rejection
                            if (error.code === 4001 || error.message.includes('rejected') || error.message.includes('denied')) {
                                throw new Error('Connection rejected by user');
                            }

                            // Handle wallet not found
                            if (error.message.includes('not found') || error.message.includes('not available')) {
                                throw new Error('Xverse wallet not detected. Please install the Xverse extension.');
                            }

                            // Re-throw other errors
                            throw error;
                        }
                    }
                },
                {
                    id: 'trustwallet',
                    name: 'Trust Wallet',
                    type: 'Bitcoin',
                    icon: 'fas fa-shield-alt',
                    isAvailable: () => {
                        // Enhanced Trust Wallet detection
                        if (window.ethereum && window.ethereum.isTrust) {
                            return true;
                        }

                        // Alternative detection methods for Trust Wallet
                        if (window.ethereum) {
                            // Check if it's Trust Wallet by examining the provider
                            const userAgent = navigator.userAgent.toLowerCase();
                            const isTrustApp = userAgent.includes('trust') || window.ethereum.constructor?.name?.includes('Trust');

                            // Check for Trust Wallet specific properties
                            const hasTrustProperties = window.ethereum.isTrust ||
                                                      (window.ethereum.providers && window.ethereum.providers.some(p => p.isTrust));

                            return isTrustApp || hasTrustProperties;
                        }

                        // Also check for mobile Trust Wallet
                        if (typeof window !== 'undefined' && window.trustwallet) {
                            return true;
                        }

                        return false;
                    },
                    connect: async () => {
                        let provider;

                        // Find Trust Wallet provider
                        if (window.ethereum && window.ethereum.isTrust) {
                            provider = window.ethereum;
                        } else if (window.ethereum && window.ethereum.providers) {
                            provider = window.ethereum.providers.find(p => p.isTrust) || window.ethereum;
                        } else {
                            provider = window.ethereum;
                        }

                        if (!provider) {
                            throw new Error('Trust Wallet provider not found');
                        }

                        const accounts = await provider.request({ method: 'eth_requestAccounts' });
                        if (!accounts || accounts.length === 0) {
                            throw new Error('No accounts found');
                        }

                        return {
                            address: accounts[0],
                            name: 'Trust Wallet',
                            provider: provider
                        };
                    }
                },
                {
                    id: 'coinbase',
                    name: 'Coinbase Wallet',
                    type: 'Bitcoin',
                    icon: 'fab fa-bitcoin',
                    isAvailable: () => {
                        // Enhanced Coinbase Wallet detection
                        if (window.ethereum && window.ethereum.isCoinbaseWallet) {
                            return true;
                        }

                        // Check if it's Coinbase Wallet by examining the provider
                        if (window.ethereum) {
                            const userAgent = navigator.userAgent.toLowerCase();
                            const isCoinbaseApp = userAgent.includes('coinbase') || window.ethereum.constructor?.name?.includes('Coinbase');

                            // Check for Coinbase Wallet specific properties
                            const hasCoinbaseProperties = window.ethereum.isCoinbaseWallet ||
                                                          (window.ethereum.providers && window.ethereum.providers.some(p => p.isCoinbaseWallet));

                            return isCoinbaseApp || hasCoinbaseProperties;
                        }

                        return false;
                    },
                    connect: async () => {
                        let provider;

                        // Find Coinbase Wallet provider
                        if (window.ethereum && window.ethereum.isCoinbaseWallet) {
                            provider = window.ethereum;
                        } else if (window.ethereum && window.ethereum.providers) {
                            provider = window.ethereum.providers.find(p => p.isCoinbaseWallet) || window.ethereum;
                        } else {
                            provider = window.ethereum;
                        }

                        if (!provider) {
                            throw new Error('Coinbase Wallet provider not found');
                        }

                        const accounts = await provider.request({ method: 'eth_requestAccounts' });
                        if (!accounts || accounts.length === 0) {
                            throw new Error('No accounts found');
                        }

                        return {
                            address: accounts[0],
                            name: 'Coinbase Wallet',
                            provider: provider
                        };
                    }
                },
                {
                    id: 'phantom',
                    name: 'Phantom',
                    type: 'Bitcoin',
                    icon: 'fas fa-ghost',
                    isAvailable: () => {
                        // Enhanced Phantom detection
                        if (window.solana && window.solana.isPhantom) {
                            return true;
                        }

                        // Check if it's Phantom by examining the provider
                        if (window.solana) {
                            const userAgent = navigator.userAgent.toLowerCase();
                            const isPhantomApp = userAgent.includes('phantom') || window.solana.constructor?.name?.includes('Phantom');

                            // Check for Phantom specific properties
                            const hasPhantomProperties = window.solana.isPhantom ||
                                                        (window.solana.isConnected && window.solana.publicKey);

                            return isPhantomApp || hasPhantomProperties;
                        }

                        return false;
                    },
                    connect: async () => {
                        if (!window.solana) {
                            throw new Error('Phantom provider not found');
                        }

                        const response = await window.solana.connect();
                        if (!response || !response.publicKey) {
                            throw new Error('No public key found');
                        }

                        return {
                            address: response.publicKey.toString(),
                            name: 'Phantom',
                            provider: window.solana
                        };
                    }
                },
                {
                    id: 'metamask',
                    name: 'MetaMask',
                    type: 'Bitcoin',
                    icon: 'fab fa-ethereum',
                    isAvailable: () => window.ethereum && window.ethereum.isMetaMask,
                    connect: async () => {
                        const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                        return { address: accounts[0], name: 'MetaMask' };
                    }
                },
                {
                    id: 'brave',
                    name: 'Brave Wallet',
                    type: 'Bitcoin',
                    icon: 'fab fa-ethereum',
                    isAvailable: () => {
                        // Enhanced Brave Wallet detection
                        if (window.ethereum && window.ethereum.isBraveWallet) {
                            return true;
                        }

                        // Check if it's Brave Wallet by examining the provider
                        if (window.ethereum) {
                            const userAgent = navigator.userAgent.toLowerCase();
                            const isBraveBrowser = userAgent.includes('brave') || window.ethereum.constructor?.name?.includes('Brave');

                            // Check for Brave Wallet specific properties
                            const hasBraveProperties = window.ethereum.isBraveWallet ||
                                                      (window.ethereum.providers && window.ethereum.providers.some(p => p.isBraveWallet));

                            return isBraveBrowser || hasBraveProperties;
                        }

                        return false;
                    },
                    connect: async () => {
                        let provider;

                        // Find Brave Wallet provider
                        if (window.ethereum && window.ethereum.isBraveWallet) {
                            provider = window.ethereum;
                        } else if (window.ethereum && window.ethereum.providers) {
                            provider = window.ethereum.providers.find(p => p.isBraveWallet) || window.ethereum;
                        } else {
                            provider = window.ethereum;
                        }

                        if (!provider) {
                            throw new Error('Brave Wallet provider not found');
                        }

                        const accounts = await provider.request({ method: 'eth_requestAccounts' });
                        if (!accounts || accounts.length === 0) {
                            throw new Error('No accounts found');
                        }

                        return {
                            address: accounts[0],
                            name: 'Brave Wallet',
                            provider: provider
                        };
                    }
                },
                {
                    id: 'generic',
                    name: 'Browser Wallet',
                    type: 'Bitcoin',
                    icon: 'fas fa-wallet',
                    isAvailable: () => {
                        // Generic wallet detection - if ethereum is available, assume it's a wallet
                        return !!window.ethereum;
                    },
                    connect: async () => {
                        if (!window.ethereum) {
                            throw new Error('No Ethereum wallet detected');
                        }

                        const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                        if (!accounts || accounts.length === 0) {
                            throw new Error('No accounts found');
                        }

                        return {
                            address: accounts[0],
                            name: 'Browser Wallet',
                            provider: window.ethereum
                        };
                    }
                }
            ];

            const starknetWallets = [
                {
                    id: 'starknet',
                    name: 'Ready Wallet',
                    type: 'StarkNet',
                    icon: 'fas fa-link',
                    isAvailable: () => window.starknet,
                    connect: async () => {
                        await window.starknet.enable();
                        return { address: window.starknet.selectedAddress, name: window.starknet.name || 'Ready Wallet' };
                    }
                },
                {
                    id: 'braavos',
                    name: 'Braavos Wallet',
                    type: 'StarkNet',
                    icon: 'fas fa-shield-alt',
                    isAvailable: () => window.starknet,
                    connect: async () => {
                        await window.starknet.enable();
                        return { address: window.starknet.selectedAddress, name: 'Braavos Wallet' };
                    }
                }
            ];

            // Return wallets based on current bridge direction
            if (currentDirection === 'to-starknet') {
                // Bitcoin to Starknet - prioritize Bitcoin wallets
                return [...bitcoinWallets, ...starknetWallets];
            } else {
                // Starknet to Bitcoin - prioritize Starknet wallets
                return [...starknetWallets, ...bitcoinWallets];
            }
        };

        // Initialize the dashboard
        async function init() {
            console.log('Initializing bridge dashboard...');
            setupEventListeners();

            // Check existing wallet connection first
            await checkExistingWalletConnection();

            // Try to initialize bridge service if wallet is connected
            if (connectedAddress) {
                try {
                    await initializeBridgeService();
                    await loadContractState();
                    startPeriodicRefresh();
                } catch (error) {
                    console.warn('Bridge service initialization deferred:', error.message);
                    // Don't show error to user yet, will retry on wallet connection
                }
            }

            console.log('Bridge dashboard initialized');
        }

        // Initialize the Starknet bridge service (direction-aware)
        async function initializeBridgeService() {
            try {
                console.log(`Starting bridge service initialization for direction: ${currentDirection}...`);

                // Update contract address in the service
                window.starknetBridgeService.contractAddress = BRIDGE_CONFIG.BRIDGE_CONTRACT;

                // Initialize the service with retry logic and direction awareness
                let retries = 0;
                const maxRetries = 3;

                while (retries < maxRetries) {
                    try {
                        await window.starknetBridgeService.initialize(currentDirection);
                        bridgeState.isInitialized = true;
                        console.log(`Bridge service initialized successfully for ${currentDirection} transfers`);
                        return;
                    } catch (error) {
                        retries++;
                        console.warn(`Bridge service initialization attempt ${retries} failed:`, error.message);

                        if (retries < maxRetries) {
                            console.log(`Retrying in ${retries * 2} seconds...`);
                            await new Promise(resolve => setTimeout(resolve, retries * 2000));
                        } else {
                            throw error;
                        }
                    }
                }
            } catch (error) {
                console.error('Failed to initialize bridge service after retries:', error);
                bridgeState.isInitialized = false;

                // Provide direction-specific error messages
                let errorMessage = `Bridge initialization failed: ${error.message}`;
                if (currentDirection === 'to-starknet') {
                    errorMessage = 'Bitcoin bridge initialization failed. Please ensure you have a Bitcoin wallet connected.';
                } else {
                    errorMessage = `Bridge initialization failed: ${error.message}`;
                }

                showNotification(errorMessage, true);
                throw error;
            }
        }

        // Load contract state (bridge status, staking data, etc.)
        async function loadContractState() {
            if (!bridgeState.isInitialized) return;

            try {
                // Check if bridge is paused
                bridgeState.isBridgePaused = await window.starknetBridgeService.isBridgePaused();
                updateBridgeStatusUI();

                // Load staking data if wallet is connected
                if (connectedAddress) {
                    await loadStakingData();
                }
            } catch (error) {
                console.error('Failed to load contract state:', error);
            }
        }

        // Load user's staking data
        async function loadStakingData() {
            try {
                const sbtcAddress = BRIDGE_CONFIG.TOKENS.SBTC.address;

                // Get staking position
                const position = await window.starknetBridgeService.getStakingPosition(
                    connectedAddress,
                    sbtcAddress
                );

                // Get user rewards
                const rewards = await window.starknetBridgeService.getUserRewards(connectedAddress);

                // Update state
                bridgeState.stakingData.stakedAmount = position ? position.amount : 0;
                bridgeState.stakingData.rewards = rewards || 0;

                // Update UI
                updateStakingUI();

            } catch (error) {
                console.error('Failed to load staking data:', error);
            }
        }

        // Update bridge status UI based on contract state
        function updateBridgeStatusUI() {
            const bridgeButton = document.getElementById('bridgeButton');
            const stakeBtn = document.getElementById('stakeBtn');
            const unstakeBtn = document.getElementById('unstakeBtn');
            const serviceStatus = document.getElementById('serviceStatus');

            // Update service status indicator
            if (serviceStatus) {
                if (bridgeState.isInitialized) {
                    serviceStatus.style.background = bridgeState.isBridgePaused ? '#f59e0b' : '#10b981';
                    serviceStatus.title = bridgeState.isBridgePaused ? 'Bridge Paused' : 'Bridge Active';
                } else {
                    serviceStatus.style.background = '#ef4444';
                    serviceStatus.title = 'Service Not Initialized';
                }
            }

            if (bridgeState.isBridgePaused) {
                if (bridgeButton) bridgeButton.disabled = true;
                if (stakeBtn) stakeBtn.disabled = true;
                if (unstakeBtn) unstakeBtn.disabled = true;

                showNotification('Bridge is currently paused. Please try again later.', true);
            } else {
                if (bridgeButton) bridgeButton.disabled = false;
                if (stakeBtn) stakeBtn.disabled = false;
                if (unstakeBtn) unstakeBtn.disabled = false;
            }
        }

        // Update staking UI with real data
        function updateStakingUI() {
            const stakedAmountEl = document.getElementById('stakedAmount');
            const stakingRewardsEl = document.getElementById('stakingRewards');

            if (stakedAmountEl) {
                stakedAmountEl.textContent = bridgeState.stakingData.stakedAmount.toFixed(6);
            }

            if (stakingRewardsEl) {
                stakingRewardsEl.textContent = bridgeState.stakingData.rewards.toFixed(6);
            }
        }

        // Periodic refresh of contract state
        async function startPeriodicRefresh() {
            // Refresh every 30 seconds
            setInterval(async () => {
                if (bridgeState.isInitialized && connectedAddress) {
                    try {
                        await loadContractState();
                    } catch (error) {
                        console.error('Failed to refresh contract state:', error);
                    }
                }
            }, 30000);
        }

        // Check if wallet is connected and bridge is ready (direction-aware)
        function ensureWalletConnected() {
            if (!connectedAddress) {
                showNotification('Please connect your wallet first', true);
                return false;
            }

            if (!bridgeState.isInitialized) {
                showNotification('Bridge service not initialized. Click "Initialize Bridge" to set up the service.', true);
                showInitializeBridgeButton();
                return false;
            }

            if (bridgeState.isBridgePaused) {
                showNotification('Bridge is currently paused. Please try again later.', true);
                return false;
            }

            return true;
        }

        // Check if wallet setup is appropriate for current bridge direction
        function checkWalletForDirection() {
            if (currentDirection === 'to-starknet') {
                // For Bitcoin→Starknet, we need Bitcoin wallet connected first
                if (!connectedAddress) {
                    showNotification('Please connect your Bitcoin wallet (Xverse Wallet, Trust Wallet, Coinbase, etc.) first.', true);
                    return false;
                }

                // More permissive Bitcoin wallet detection
                const walletName = connectedWallet ? connectedWallet.toLowerCase() : '';
                const isBitcoinWallet = walletName.includes('xverse') ||
                                  walletName.includes('trust') ||
                                  walletName.includes('coinbase') ||
                                  walletName.includes('phantom') ||
                                  walletName.includes('metamask') ||
                                  walletName.includes('brave') ||
                                  walletName.includes('wallet') ||
                                  window.ethereum; // If ethereum is available, assume it's a Bitcoin-compatible wallet

                if (!isBitcoinWallet) {
                    showNotification('Please connect a Bitcoin-compatible wallet for Bitcoin→Starknet transfers.', true);
                    return false;
                }

                return true;
            } else {
                // For Starknet→Bitcoin, we need Bitcoin wallet for destination address, Starknet wallet only for transaction execution
                if (!connectedAddress) {
                    showNotification('Please connect your Bitcoin wallet (Xverse Wallet, Trust Wallet, Coinbase, etc.) to set the destination address.', true);
                    return false;
                }

                // For Starknet→Bitcoin, Bitcoin wallet is used for destination address
                // Starknet wallet will be required only when executing the transaction
                const walletName = connectedWallet ? connectedWallet.toLowerCase() : '';
                const isBitcoinWallet = walletName.includes('xverse') ||
                                      walletName.includes('trust') ||
                                      walletName.includes('coinbase') ||
                                      walletName.includes('phantom') ||
                                      walletName.includes('metamask') ||
                                      walletName.includes('brave') ||
                                      walletName.includes('wallet') ||
                                      window.ethereum;

                if (!isBitcoinWallet) {
                    showNotification('Please connect a Bitcoin wallet for Starknet→Bitcoin transfers.', true);
                    return false;
                }

                return true;
            }
        }

        // Show initialize bridge button
        function showInitializeBridgeButton() {
            const bridgeButton = document.getElementById('bridgeButton');
            const originalText = bridgeButton.innerHTML;

            bridgeButton.innerHTML = '<i class="fas fa-cog"></i> Initialize Bridge';
            bridgeButton.onclick = async () => {
                try {
                    bridgeButton.disabled = true;
                    bridgeButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Initializing...';

                    await initializeBridgeService();
                    await loadContractState();
                    startPeriodicRefresh();

                    bridgeButton.innerHTML = originalText;
                    bridgeButton.onclick = () => bridgeForm.dispatchEvent(new Event('submit'));

                    showNotification('Bridge service initialized successfully!');
                } catch (error) {
                    console.error('Manual initialization failed:', error);
                    showNotification(`Initialization failed: ${error.message}`, true);
                    bridgeButton.innerHTML = '<i class="fas fa-cog"></i> Initialize Bridge';
                } finally {
                    bridgeButton.disabled = false;
                }
            };
        }

        // Enhanced error handling for contract interactions
        function handleContractError(error, operation) {
            console.error(`${operation} error:`, error);

            let userMessage = `${operation} failed`;

            if (error.message) {
                if (error.message.includes('rejected') || error.message.includes('User denied')) {
                    userMessage = 'Transaction rejected by user';
                } else if (error.message.includes('insufficient') || error.message.includes('balance')) {
                    userMessage = 'Insufficient balance for this transaction';
                } else if (error.message.includes('paused')) {
                    userMessage = 'Bridge is currently paused. Please try again later.';
                } else if (error.message.includes('limit')) {
                    userMessage = 'Transaction exceeds bridge limits.';
                } else if (error.message.includes('nonce')) {
                    userMessage = 'Transaction nonce error. Please try again.';
                } else {
                    userMessage = error.message;
                }
            }

            showNotification(`❌ ${userMessage}`, true);
        }

        // Check for existing wallet connection on page load (no auto-connect)
        async function checkExistingWalletConnection() {
            try {
                // Only check if wallets are available, don't auto-connect
                console.log('Checking wallet availability without auto-connection...');

                // Check if Xverse is available
                const xverseWallet = {
                    id: 'xverse',
                    name: 'Xverse Wallet',
                    type: 'Bitcoin',
                    isAvailable: () => {
                        try {
                            if (typeof window !== 'undefined' && window.xverse) {
                                return true;
                            }

                            if (window.ethereum) {
                                if (window.ethereum.isXverse ||
                                    window.ethereum.constructor?.name?.includes('Xverse') ||
                                    window.ethereum.constructor?.toString().toLowerCase().includes('xverse')) {
                                    return true;
                                }

                                if (window.ethereum.providers && Array.isArray(window.ethereum.providers)) {
                                    const xverseProvider = window.ethereum.providers.find(p =>
                                        p.isXverse ||
                                        p.constructor?.name?.includes('Xverse') ||
                                        p.constructor?.toString().toLowerCase().includes('xverse')
                                    );
                                    if (xverseProvider) return true;
                                }
                            }

                            if (typeof navigator !== 'undefined') {
                                const userAgent = navigator.userAgent.toLowerCase();
                                if (userAgent.includes('xverse') ||
                                    userAgent.includes('xversewallet') ||
                                    userAgent.includes('xverse-bitcoin')) {
                                    return true;
                                }
                            }

                            return false;
                        } catch (error) {
                            return false;
                        }
                    }
                };

                // Check if Ready wallet is available
                const readyWallet = {
                    id: 'starknet',
                    name: 'Ready Wallet',
                    type: 'StarkNet',
                    isAvailable: () => window.starknet
                };

                console.log('Xverse wallet available:', xverseWallet.isAvailable());
                console.log('Ready wallet available:', readyWallet.isAvailable());

            } catch (error) {
                console.error('Error checking wallet availability:', error);
            }
        }

        // Get Ethereum wallet name
        function getEthereumWalletName() {
            if (window.ethereum.isMetaMask) return 'MetaMask';
            if (window.ethereum.isCoinbaseWallet) return 'Coinbase Wallet';

            // Enhanced Trust Wallet detection
            if (window.ethereum.isTrust) return 'Trust Wallet';

            // Alternative Trust Wallet detection
            if (window.ethereum.providers && window.ethereum.providers.some(p => p.isTrust)) {
                return 'Trust Wallet';
            }

            // Check user agent for mobile Trust Wallet
            const userAgent = navigator.userAgent.toLowerCase();
            if (userAgent.includes('trust')) {
                return 'Trust Wallet';
            }

            if (window.ethereum.isExodus) return 'Exodus';
            if (window.ethereum.isLedger) return 'Ledger';
            if (window.ethereum.isTrezor) return 'Trezor';
            return 'Ethereum Wallet';
        }

        // Debug wallet detection
        window.debugWalletDetection = function() {
            console.log('🔍 Wallet Detection Debug');
            console.log('window.ethereum:', !!window.ethereum);
            console.log('window.starknet:', !!window.starknet);

            if (window.ethereum) {
                console.log('Ethereum provider details:', {
                    isMetaMask: window.ethereum.isMetaMask,
                    isCoinbaseWallet: window.ethereum.isCoinbaseWallet,
                    isTrust: window.ethereum.isTrust,
                    isBraveWallet: window.ethereum.isBraveWallet,
                    isOpera: window.ethereum.isOpera,
                    isFrame: window.ethereum.isFrame,
                    isStatus: window.ethereum.isStatus,
                    constructorName: window.ethereum.constructor?.name,
                    providers: window.ethereum.providers?.map(p => ({
                        isMetaMask: p.isMetaMask,
                        isTrust: p.isTrust,
                        isCoinbaseWallet: p.isCoinbaseWallet,
                        constructorName: p.constructor?.name
                    }))
                });
            }

            // Test wallet availability
            console.log('Wallet availability test:');
            const wallets = getAvailableWallets();
            wallets.forEach(wallet => {
                try {
                    const isAvailable = wallet.isAvailable();
                    console.log(`${wallet.name}: ${isAvailable ? '✅ Available' : '❌ Not Available'}`);
                } catch (error) {
                    console.log(`${wallet.name}: ❌ Error - ${error.message}`);
                }
            });

            return {
                ethereum: !!window.ethereum,
                starknet: !!window.starknet,
                walletName: window.ethereum ? getEthereumWalletName() : 'No Ethereum wallet'
            };
        };

        // Refresh wallet detection (useful if wallet loads after page load)
        window.refreshWalletDetection = function() {
            console.log('🔄 Refreshing wallet detection...');

            // Repopulate wallet options with fresh detection
            populateWalletOptions();

            // Show notification
            showNotification('Wallet detection refreshed!');

            return debugWalletDetection();
        };

        // Show all available wallets with detailed status
        window.showAllWallets = function() {
            console.log('📋 All Available Wallets Status');
            console.log('================================');

            const wallets = getAvailableWallets();
            wallets.forEach(wallet => {
                try {
                    const isAvailable = wallet.isAvailable();
                    const status = isAvailable ? '✅ AVAILABLE' : '❌ NOT AVAILABLE';
                    const icon = isAvailable ? '🟢' : '🔴';

                    console.log(`${icon} ${wallet.name} (${wallet.type}) - ${status}`);

                    if (isAvailable) {
                        console.log(`   💡 Ready to connect`);
                    } else {
                        console.log(`   ⚠️  Not detected or not installed`);
                    }
                } catch (error) {
                    console.log(`🔴 ${wallet.name} (${wallet.type}) - ❌ ERROR: ${error.message}`);
                }
                console.log('');
            });

            // Summary
            const availableCount = wallets.filter(w => w.isAvailable()).length;
            const totalCount = wallets.length;

            console.log(`📊 Summary: ${availableCount}/${totalCount} wallets available`);

            if (availableCount > 0) {
                console.log('💡 Tip: Click "Connect Wallet" to see available options');
            } else {
                console.log('⚠️  No wallets detected. Make sure you have wallet extensions installed.');
            }

            return {
                total: totalCount,
                available: availableCount,
                wallets: wallets.map(w => ({
                    name: w.name,
                    type: w.type,
                    available: w.isAvailable()
                }))
            };
        };

        // Set up wallet event listeners
        function setupWalletEventListeners() {
            // Listen for wallet events
            if (window.ethereum) {
                window.ethereum.on('accountsChanged', handleAccountsChanged);
                window.ethereum.on('chainChanged', handleChainChanged);
                window.ethereum.on('disconnect', handleDisconnect);
            }

            if (window.starknet) {
                window.starknet.on('accountsChanged', handleStarknetAccountsChanged);
                window.starknet.on('networkChanged', handleStarknetNetworkChanged);
            }
        }

        // Handle account changes
        function handleAccountsChanged(accounts) {
            if (accounts.length === 0) {
                // User disconnected
                disconnectWallet();
            } else if (accounts[0] !== connectedAddress) {
                // Account changed
                connectedAddress = accounts[0];
                updateWalletUI();
                showNotification('Account changed in wallet');
                useConnectedAddressForForms();
            }
        }

        // Handle chain changes
        function handleChainChanged(chainId) {
            showNotification(`Network changed to ${getNetworkName(chainId)}`);
        }

        // Handle disconnect
        function handleDisconnect() {
            disconnectWallet();
            showNotification('Wallet disconnected');
        }

        // Handle Starknet account changes
        function handleStarknetAccountsChanged(accounts) {
            if (!accounts || accounts.length === 0) {
                disconnectWallet();
            } else if (accounts[0] !== connectedAddress) {
                connectedAddress = accounts[0];
                updateWalletUI();
                showNotification('Starknet account changed');
                useConnectedAddressForForms();
            }
        }

        // Handle Starknet network changes
        function handleStarknetNetworkChanged(network) {
            showNotification('Starknet network changed');
        }

        // Handle Starknet accounts changes
        function handleStarknetAccountsChanged(accounts) {
            if (!accounts || accounts.length === 0) {
                disconnectWallet();
            } else if (accounts[0] !== connectedAddress) {
                connectedAddress = accounts[0];
                updateWalletUI();
                showNotification('Starknet account changed');
                useConnectedAddressForForms();
            }
        }

        // Get network name from chain ID
        function getNetworkName(chainId) {
            const networks = {
                '0x1': 'Ethereum Mainnet',
                '0x5': 'Goerli Testnet',
                '0xaa36a7': 'Sepolia Testnet',
                '0x89': 'Polygon Mainnet'
            };
            return networks[chainId] || `Chain ${chainId}`;
        }

        // Set up event listeners
        function setupEventListeners() {
            // Wallet connection events


            // Network direction selection
            networkOptions.forEach(option => {
                option.addEventListener('click', function() {
                    networkOptions.forEach(opt => opt.classList.remove('active'));
                    this.classList.add('active');
                    currentDirection = this.dataset.direction;
                    updateUIForDirection();
                    refreshWalletOptionsForDirection();
                });
            });

            // Max button
            maxButton.addEventListener('click', setMaxAmount);

            // Bridge form submission
            bridgeForm.addEventListener('submit', function(e) {
                e.preventDefault();
                initiateBridgeTransfer();
            });

            // Staking button events
            if (stakeBtn) {
                stakeBtn.addEventListener('click', function() {
                    const amount = prompt('Enter amount to stake (SBTC):');
                    if (amount && parseFloat(amount) > 0) {
                        stakeTokens(amount);
                    }
                });
            }

            if (unstakeBtn) {
                unstakeBtn.addEventListener('click', function() {
                    const amount = prompt('Enter amount to unstake (SBTC):');
                    if (amount && parseFloat(amount) > 0) {
                        unstakeTokens(amount);
                    }
                });
            }

            if (claimRewardsBtn) {
                claimRewardsBtn.addEventListener('click', function() {
                    claimStakingRewards();
                });
            }

            // Starknet wallet connection for Bitcoin→Starknet transfers
            if (connectStarknetBtn) {
                connectStarknetBtn.addEventListener('click', async function() {
                    try {
                        connectStarknetBtn.disabled = true;
                        connectStarknetBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Connecting...';

                        const success = await connectStarknetWalletForBitcoinBridge();
                        if (success) {
                            updateWalletStatusDisplay();
                            showNotification('Starknet wallet connected! Ready to bridge Bitcoin→Starknet.');
                        }
                    } catch (error) {
                        console.error('Failed to connect Starknet wallet:', error);
                        showNotification(`Failed to connect Starknet wallet: ${error.message}`, true);
                    } finally {
                        connectStarknetBtn.disabled = false;
                        connectStarknetBtn.innerHTML = '<i class="fas fa-link"></i> Connect Starknet Wallet';
                    }
                });
            }

            // Xverse wallet connection
            if (connectXverseBtn) {
                connectXverseBtn.addEventListener('click', async function() {
                    try {
                        connectXverseBtn.disabled = true;
                        connectXverseBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Connecting...';

                        await connectToSpecificWallet('xverse');
                    } catch (error) {
                        console.error('Failed to connect Xverse wallet:', error);
                        showNotification(`Failed to connect Xverse wallet: ${error.message}`, true);
                    } finally {
                        connectXverseBtn.disabled = false;
                        connectXverseBtn.innerHTML = '<i class="fas fa-bitcoin"></i> Connect Xverse Wallet';
                    }
                });
            }

            // Ready wallet connection
            if (connectReadyBtn) {
                connectReadyBtn.addEventListener('click', async function() {
                    try {
                        connectReadyBtn.disabled = true;
                        connectReadyBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Connecting...';

                        await connectToSpecificWallet('starknet');
                    } catch (error) {
                        console.error('Failed to connect Ready wallet:', error);
                        showNotification(`Failed to connect Ready wallet: ${error.message}`, true);
                    } finally {
                        connectReadyBtn.disabled = false;
                        connectReadyBtn.innerHTML = '<i class="fas fa-link"></i> Connect Ready Wallet';
                    }
                });
            }
        }

        // Detect if device is mobile
        function isMobile() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                   window.innerWidth <= 768;
        }

        // Check if wallet extension is installed
        function checkWalletExtension(walletId) {
            try {
                switch (walletId) {
                    case 'metamask':
                        return typeof window.ethereum !== 'undefined' && window.ethereum.isMetaMask;
                    case 'trust':
                        return typeof window.ethereum !== 'undefined' && window.ethereum.isTrust;
                    case 'coinbase':
                        return typeof window.ethereum !== 'undefined' && window.ethereum.isCoinbaseWallet;
                    case 'brave':
                        return typeof window.ethereum !== 'undefined' && window.ethereum.isBraveWallet;
                    case 'opera':
                        return typeof window.ethereum !== 'undefined' && window.ethereum.isOpera;
                    case 'frame':
                        return typeof window.ethereum !== 'undefined' && window.ethereum.isFrame;
                    case 'status':
                        return typeof window.ethereum !== 'undefined' && window.ethereum.isStatus;
                    case 'phantom':
                        return typeof window.solana !== 'undefined' && window.solana.isPhantom;
                    case 'solflare':
                        return typeof window.solflare !== 'undefined' && window.solflare.isSolflare;
                    case 'starknet':
                    case 'argent':
                    case 'braavos':
                        return typeof window.starknet !== 'undefined';
                    default:
                        return false;
                }
            } catch (e) {
                return false;
            }
        }

        // Populate wallet options with real available wallets (context-aware)
        function populateWalletOptions() {
            walletOptionsContainer.innerHTML = '';

            const wallets = getAvailableWallets();

            wallets.forEach(wallet => {
                const isAvailable = wallet.isAvailable();
                const optionElement = document.createElement('div');
                optionElement.className = `wallet-option ${isAvailable ? 'available' : 'unavailable'}`;
                if (isAvailable) {
                    optionElement.onclick = () => connectToRealWallet(wallet);
                }

                optionElement.innerHTML = `
                    <div class="wallet-icon">
                        <i class="${wallet.icon}"></i>
                    </div>
                    <div class="wallet-info">
                        <div class="wallet-name">${wallet.name}</div>
                        <div class="wallet-type">${wallet.type}</div>
                    </div>
                    <div class="wallet-status">
                        ${isAvailable ? 'Available' : 'Not Installed'}
                    </div>
                `;

                // Add visual styling based on wallet priority for current direction
                if (isAvailable) {
                    const wallets = getAvailableWallets();
                    const walletIndex = wallets.findIndex(w => w.id === wallet.id);

                    if (walletIndex < 3) {
                        // Top 3 wallets for current direction get special styling
                        optionElement.style.borderColor = 'var(--primary)';
                        optionElement.style.background = 'rgba(124, 58, 237, 0.05)';
                    }
                }

                walletOptionsContainer.appendChild(optionElement);
            });
        }

        // Modal functions
        function openWalletModal() {
            console.log(`🔄 Opening wallet modal for ${currentDirection} bridge`);

            // Update modal title based on current direction
            const modalTitle = document.querySelector('.modal-title');
            if (modalTitle) {
                if (currentDirection === 'to-starknet') {
                    modalTitle.textContent = 'Connect Bitcoin Wallet';
                    console.log('💡 Modal title set to: Connect Bitcoin Wallet');
                } else {
                    modalTitle.textContent = 'Connect Starknet Wallet';
                    console.log('💡 Modal title set to: Connect Starknet Wallet');
                }
            }

            // Populate wallet options (this will show Bitcoin wallets first for to-starknet direction)
            populateWalletOptions();
            walletModal.style.display = 'flex';

            // Debug: Show what wallets are being displayed
            const wallets = getAvailableWallets();
            console.log(`📋 Displaying ${wallets.length} wallets for ${currentDirection}:`);
            wallets.forEach((wallet, index) => {
                console.log(`  ${index + 1}. ${wallet.name} (${wallet.type})`);
            });
        }

        function closeWalletModal() {
            walletModal.style.display = 'none';
        }

        // Populate wallet options with real available wallets (context-aware)
        function populateWalletOptions() {
            walletOptionsContainer.innerHTML = '';

            const wallets = getAvailableWallets();

            wallets.forEach(wallet => {
                const isAvailable = wallet.isAvailable();
                const optionElement = document.createElement('div');
                optionElement.className = `wallet-option ${isAvailable ? 'available' : 'unavailable'}`;
                if (isAvailable) {
                    optionElement.onclick = () => connectToRealWallet(wallet);
                }

                optionElement.innerHTML = `
                    <div class="wallet-icon">
                        <i class="${wallet.icon}"></i>
                    </div>
                    <div class="wallet-info">
                        <div class="wallet-name">${wallet.name}</div>
                        <div class="wallet-type">${wallet.type}</div>
                    </div>
                    <div class="wallet-status">
                        ${isAvailable ? 'Available' : 'Not Installed'}
                    </div>
                `;

                // Add visual styling based on wallet priority for current direction
                if (isAvailable) {
                    const walletIndex = wallets.findIndex(w => w.id === wallet.id);

                    if (wallet.id === 'xverse') {
                        // Xverse Wallet gets special priority styling as the real wallet
                        optionElement.style.borderColor = 'var(--primary)';
                        optionElement.style.background = 'rgba(124, 58, 237, 0.1)';
                        optionElement.style.borderWidth = '2px';
                        optionElement.style.fontWeight = '600';
                    } else if (walletIndex < 3) {
                        // Top 3 wallets for current direction get special styling
                        optionElement.style.borderColor = 'var(--primary)';
                        optionElement.style.background = 'rgba(124, 58, 237, 0.05)';
                    }
                }

                walletOptionsContainer.appendChild(optionElement);
            });
        }

        // Connect to real wallet (direction-aware)
        async function connectToRealWallet(wallet) {
            try {
                closeWalletModal();
                showNotification(`Connecting to ${wallet.name}...`);

                const result = await wallet.connect();

                connectedWallet = result.name;
                connectedAddress = result.address;

                updateWalletUI();
                showNotification(`Successfully connected to ${connectedWallet}!`);

                // Initialize bridge service after successful wallet connection (direction-aware)
                try {
                    await initializeBridgeService();
                    await loadContractState();
                    startPeriodicRefresh();

                    // Direction-specific success messages
                    if (currentDirection === 'to-starknet') {
                        showNotification('✅ Bitcoin wallet connected! You can now proceed with your Bitcoin→Starknet transfer.');
                    } else {
                        showNotification('Starknet wallet connected! Bridge service ready!');
                    }
                } catch (bridgeError) {
                    console.warn('Bridge service initialization failed:', bridgeError.message);

                    if (currentDirection === 'to-starknet') {
                        showNotification('✅ Bitcoin wallet connected! Ready for Bitcoin→Starknet transfer.', false);
                    } else {
                        showNotification('Wallet connected but bridge service needs manual initialization', true);
                    }
                }

            } catch (error) {
                console.error('Wallet connection error:', error);
                showNotification(`Failed to connect to ${wallet.name}: ${error.message}`, true);
            }
        }

        // Connect to specific wallet by ID
        async function connectToSpecificWallet(walletId) {
            try {
                showNotification(`Connecting to ${walletId === 'xverse' ? 'Xverse' : 'Ready'} wallet...`);

                // Get available wallets
                const wallets = getAvailableWallets();

                // Find the specific wallet
                const targetWallet = wallets.find(wallet => wallet.id === walletId);

                if (!targetWallet) {
                    // If Xverse wallet not found in configured wallets, try fallback detection
                    if (walletId === 'xverse') {
                        console.log('⚠️ Xverse wallet not found in configured wallets, trying fallback detection...');

                        // Try to detect Xverse through ethereum provider
                        if (window.ethereum && typeof window.ethereum.request === 'function') {
                            console.log('✅ Using ethereum provider as fallback for Xverse');
                            const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                            if (accounts && accounts.length > 0) {
                                return {
                                    address: accounts[0],
                                    name: 'Xverse Wallet',
                                    provider: window.ethereum
                                };
                            }
                        }

                        throw new Error('Xverse wallet not found. Please ensure Xverse extension is installed and enabled.');
                    }

                    // If Xverse wallet not found in configured wallets, try fallback detection
                    if (walletId === 'xverse') {
                        console.log('⚠️ Xverse wallet not found in configured wallets, trying fallback detection...');

                        // Try to detect Xverse through ethereum provider
                        if (window.ethereum && typeof window.ethereum.request === 'function') {
                            console.log('✅ Using ethereum provider as fallback for Xverse');
                            const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                            if (accounts && accounts.length > 0) {
                                return {
                                    address: accounts[0],
                                    name: 'Xverse Wallet',
                                    provider: window.ethereum
                                };
                            }
                        }

                        throw new Error('Xverse wallet not found. Please ensure Xverse extension is installed and enabled. If you have Xverse installed, try refreshing the page or checking if it appears in the main wallet modal.');
                    }

                    throw new Error(`${walletId === 'xverse' ? 'Xverse' : 'Ready'} wallet not found in available wallets`);
                }

                // Check if wallet is available
                if (!targetWallet.isAvailable()) {
                    // For Xverse, try fallback detection
                    if (walletId === 'xverse' && window.ethereum) {
                        console.log('⚠️ Xverse not detected by standard method, trying fallback...');
                        const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                        if (accounts && accounts.length > 0) {
                            return {
                                address: accounts[0],
                                name: 'Xverse Wallet',
                                provider: window.ethereum
                            };
                        }
                    }

                    throw new Error(`${walletId === 'xverse' ? 'Xverse' : 'Ready'} wallet is not installed or not available. Please ensure the extension is enabled and try refreshing the page.`);
                }

                // Connect to the wallet
                const result = await targetWallet.connect();

                connectedWallet = result.name;
                connectedAddress = result.address;

                updateWalletUI();
                updateWalletStatusDisplay();
                showNotification(`✅ Successfully connected to ${connectedWallet}!`);

                // Initialize bridge service after successful wallet connection
                try {
                    await initializeBridgeService();
                    await loadContractState();
                    startPeriodicRefresh();

                    // Direction-specific success messages
                    if (walletId === 'xverse') {
                        showNotification('✅ Xverse wallet connected! Ready to receive BTC from Starknet bridge.');
                    } else {
                        showNotification('✅ Ready wallet connected! Ready for Starknet operations.');
                    }
                } catch (bridgeError) {
                    console.warn('Bridge service initialization failed:', bridgeError.message);

                    if (walletId === 'xverse') {
                        showNotification('✅ Xverse wallet connected! Ready to receive BTC.', false);
                    } else {
                        showNotification('✅ Ready wallet connected! Bridge service ready.', false);
                    }
                }

            } catch (error) {
                console.error(`Failed to connect to ${walletId} wallet:`, error);
                showNotification(`Failed to connect to ${walletId === 'xverse' ? 'Xverse' : 'Ready'} wallet: ${error.message}`, true);
                throw error;
            }
        }


        // Disconnect wallet
        async function disconnectWallet(event) {
            if (event) {
                event.stopPropagation();
            }

            // Reset connection state
            connectedWallet = null;
            connectedAddress = null;

            // Update UI
            updateWalletUI();
            showNotification('Wallet disconnected');

            // Hide Starknet connect section
            if (starknetConnectSection) {
                starknetConnectSection.style.display = 'none';
            }

            // Clear address inputs if they exist
            if (typeof fromAddressInput !== 'undefined' && fromAddressInput) {
                fromAddressInput.value = '';
                if (typeof updateValidationMessage !== 'undefined') {
                    updateValidationMessage('', '');
                }
            }

            if (typeof toAddressInput !== 'undefined' && toAddressInput) {
                toAddressInput.value = '';
                if (typeof updateToAddressValidationMessage !== 'undefined') {
                    updateToAddressValidationMessage('', '');
                }
            }
        }

        // Helper function to get wallet name
        function getWalletName(walletId) {
            const walletNames = {
                'starknet': 'Ready Wallet',
                'argent': 'Argent X',
                'braavos': 'Braavos',
                'trust': 'Trust Wallet',
                'trustwallet': 'Trust Wallet',
                'metamask': 'MetaMask',
                'coinbase': 'Coinbase Wallet',
                'phantom': 'Phantom',
                'solflare': 'Solflare',
                'brave': 'Brave Wallet',
                'opera': 'Opera Wallet',
                'frame': 'Frame',
                'status': 'Status'
            };
            return walletNames[walletId] || walletId;
        }

        // Auto-populate forms with connected wallet address (direction-aware)
        function useConnectedAddressForForms() {
            if (connectedAddress) {
                console.log(`🔄 Populating form with connected wallet address for ${currentDirection} transfer`);

                // Determine which address field to populate based on current direction
                const isBitcoinToStarknet = currentDirection === 'to-starknet';

                if (isBitcoinToStarknet) {
                    // For Bitcoin→Starknet, populate FROM address (Bitcoin wallet)
                    console.log('💡 Bitcoin→Starknet: Populating FROM address with Bitcoin wallet');
                    if (fromAddressInput) {
                        fromAddressInput.value = connectedAddress;
                        validateAddress(connectedAddress); // This will validate as Bitcoin address
                        showNotification('Bitcoin wallet address set as source address');
                    }
                } else {
                    // For Starknet→Bitcoin, populate FROM address (Starknet wallet)
                    console.log('💡 Starknet→Bitcoin: Populating FROM address with Starknet wallet');
                    if (fromAddressInput) {
                        fromAddressInput.value = connectedAddress;
                        validateAddress(connectedAddress); // This will validate as Starknet address
                        showNotification('Starknet wallet address set as source address');
                    }
                }
            } else {
                showNotification('No wallet connected. Please connect a wallet first.', true);
            }
        }

        // Connect to Argent X wallet
        async function connectArgentWallet() {
            if (typeof window.starknet === 'undefined') {
                throw new Error('Argent X not detected. Please install the extension.');
            }

            try {
                // Enable the wallet
                await window.starknet.enable();

                // Get the address
                const address = window.starknet.selectedAddress || window.starknet.account?.address;

                if (!address) {
                    throw new Error('Could not get wallet address');
                }

                // Set up the starknet object for the bridge service
                window.starknet.provider = window.starknet;
                window.starknet.account = {
                    address: address,
                    execute: async function(transaction) {
                        return await window.starknet.account.execute(transaction);
                    }
                };

                return {
                    address,
                    name: 'Argent X',
                    provider: window.starknet,
                    isConnected: true
                };
            } catch (error) {
                if (error.message.includes('User rejected')) {
                    throw new Error('Connection rejected by user');
                } else if (error.message.includes('Not detected')) {
                    throw new Error('Argent X not found. Please install the extension.');
                } else {
                    throw new Error(`Connection failed: ${error.message}`);
                }
            }
        }

        // Connect to Braavos wallet
        async function connectBraavosWallet() {
            if (typeof window.starknet === 'undefined') {
                throw new Error('Braavos not detected. Please install the extension.');
            }

            try {
                // Enable the wallet
                await window.starknet.enable();

                // Get the address
                const address = window.starknet.selectedAddress || window.starknet.account?.address;

                if (!address) {
                    throw new Error('Could not get wallet address');
                }

                // Set up the starknet object for the bridge service
                window.starknet.provider = window.starknet;
                window.starknet.account = {
                    address: address,
                    execute: async function(transaction) {
                        return await window.starknet.account.execute(transaction);
                    }
                };

                return {
                    address,
                    name: 'Braavos',
                    provider: window.starknet,
                    isConnected: true
                };
            } catch (error) {
                if (error.message.includes('User rejected')) {
                    throw new Error('Connection rejected by user');
                } else if (error.message.includes('Not detected')) {
                    throw new Error('Braavos not found. Please install the extension.');
                } else {
                    throw new Error(`Connection failed: ${error.message}`);
                }
            }
        }

        // Connect to Trust wallet
        async function connectTrustWallet() {
            let provider;

            // Check for Trust Wallet in different ways
            if (typeof window.trustwallet !== 'undefined') {
                provider = window.trustwallet;
            } else if (window.ethereum && window.ethereum.isTrust) {
                provider = window.ethereum;
            } else if (window.ethereum && window.ethereum.providers) {
                // Look for Trust Wallet in the providers array
                provider = window.ethereum.providers.find(p => p.isTrust);
            } else {
                throw new Error('Trust Wallet not detected. Please install the extension.');
            }

            try {
                // Request account access
                const accounts = await provider.request({
                    method: 'eth_requestAccounts'
                });

                if (!accounts || accounts.length === 0) {
                    throw new Error('No accounts found');
                }

                // Get chain ID to verify connection
                const chainId = await provider.request({
                    method: 'eth_chainId'
                });

                return {
                    address: accounts[0],
                    name: 'Trust Wallet',
                    provider: provider,
                    chainId: chainId
                };
            } catch (error) {
                if (error.code === 4001) {
                    throw new Error('Connection rejected by user');
                } else if (error.code === -32002) {
                    throw new Error('Connection request already pending. Check your wallet.');
                } else {
                    throw new Error(`Connection failed: ${error.message}`);
                }
            }
        }

        // Connect to MetaMask wallet
        async function connectMetaMaskWallet() {
            if (typeof window.ethereum === 'undefined' || !window.ethereum.isMetaMask) {
                throw new Error('MetaMask not detected. Please install the extension.');
            }

            try {
                // Request account access
                const accounts = await window.ethereum.request({
                    method: 'eth_requestAccounts'
                });

                if (!accounts || accounts.length === 0) {
                    throw new Error('No accounts found');
                }

                // Get chain ID to verify connection
                const chainId = await window.ethereum.request({
                    method: 'eth_chainId'
                });

                // Verify MetaMask is connected
                const isConnected = window.ethereum.isConnected?.() || true;

                return {
                    address: accounts[0],
                    name: 'MetaMask',
                    provider: window.ethereum,
                    chainId: chainId,
                    isConnected: isConnected
                };
            } catch (error) {
                if (error.code === 4001) {
                    throw new Error('Connection rejected by user');
                } else if (error.code === -32002) {
                    throw new Error('Connection request already pending. Check your MetaMask.');
                } else if (error.code === 4100) {
                    throw new Error('Unauthorized - Please check your MetaMask settings');
                } else {
                    throw new Error(`Connection failed: ${error.message}`);
                }
            }
        }

        // Update wallet UI
        function updateWalletUI() {
            // Reset all wallet buttons to disconnected state
            const xverseBtn = document.getElementById('connectXverseBtn');
            const readyBtn = document.getElementById('connectReadyBtn');

            // Reset Xverse button
            if (xverseBtn) {
                xverseBtn.innerHTML = '<i class="fas fa-bitcoin" style="color: #f7931a;"></i> Xverse';
                xverseBtn.classList.remove('connected');
            }

            // Reset Ready button
            if (readyBtn) {
                readyBtn.innerHTML = '<i class="fas fa-link" style="color: var(--primary);"></i> Ready';
                readyBtn.classList.remove('connected');
            }

            // Update the appropriate button based on connected wallet
            if (connectedWallet && connectedAddress) {
                const shortAddress = `${connectedAddress.substring(0, 6)}...${connectedAddress.substring(connectedAddress.length - 4)}`;

                if (connectedWallet.toLowerCase().includes('xverse')) {
                    // Update Xverse button
                    if (xverseBtn) {
                        xverseBtn.innerHTML = `
                            <i class="fas fa-bitcoin" style="color: #f7931a;"></i> ${shortAddress}
                            <span class="disconnect-btn" onclick="disconnectWallet(event)" title="Disconnect Wallet">
                                <i class="fas fa-times"></i>
                            </span>
                        `;
                        xverseBtn.classList.add('connected');
                    }
                } else if (connectedWallet.toLowerCase().includes('ready') || connectedWallet.toLowerCase().includes('starknet')) {
                    // Update Ready button
                    if (readyBtn) {
                        readyBtn.innerHTML = `
                            <i class="fas fa-link" style="color: var(--primary);"></i> ${shortAddress}
                            <span class="disconnect-btn" onclick="disconnectWallet(event)" title="Disconnect Wallet">
                                <i class="fas fa-times"></i>
                            </span>
                        `;
                        readyBtn.classList.add('connected');
                    }
                }
            }

            // Update wallet status display
            updateWalletStatusDisplay();
        }

        // Update wallet status display
        function updateWalletStatusDisplay() {
            const walletStatusText = document.getElementById('walletStatusText');
            const starknetConnectSection = document.getElementById('starknetConnectSection');
            if (!walletStatusText) return;

            if (currentDirection === 'to-starknet') {
                // Bitcoin→Starknet direction
                if (connectedWallet && connectedAddress) {
                    const walletName = connectedWallet.toLowerCase();
                    const isBitcoinWallet = walletName.includes('trust') || walletName.includes('coinbase') ||
                                          walletName.includes('phantom') || walletName.includes('metamask') ||
                                          walletName.includes('brave') || walletName.includes('wallet') || window.ethereum;

                    if (isBitcoinWallet) {
                        if (connectedWallet === 'Xverse Wallet') {
                            walletStatusText.textContent = `✅ Xverse Wallet (Real Wallet) connected! Ready to set destination address and bridge Bitcoin→Starknet.`;
                            walletStatusText.style.color = 'var(--secondary)';
                        } else {
                            walletStatusText.textContent = `✅ Bitcoin wallet connected: ${connectedWallet}. Ready to set destination address and bridge!`;
                            walletStatusText.style.color = 'var(--secondary)';
                        }

                        // Show Starknet connect button if Starknet wallet not connected
                        if (!window.starknet || (!window.starknet.isConnected && !window.starknet.selectedAddress)) {
                            starknetConnectSection.style.display = 'block';
                        } else {
                            starknetConnectSection.style.display = 'none';
                        }
                    } else {
                        walletStatusText.textContent = `⚠️ Connected wallet may not be Bitcoin-compatible. For Bitcoin→Starknet transfers, please use Xverse Wallet, Trust Wallet, Coinbase, Phantom, MetaMask, or other Bitcoin-compatible wallets.`;
                        walletStatusText.style.color = 'var(--warning)';
                        starknetConnectSection.style.display = 'none';
                    }
                } else {
                    walletStatusText.textContent = '💡 Connect your Bitcoin wallet first (Trust Wallet, Coinbase, Phantom, MetaMask), then connect your Starknet wallet when ready to execute the bridge.';
                    walletStatusText.style.color = 'var(--gray)';
                    starknetConnectSection.style.display = 'none';
                }
            } else {
                // Starknet→Bitcoin direction - Xverse wallet for receiving BTC, Ready wallet for Starknet operations
                if (connectedWallet && connectedAddress) {
                    const walletName = connectedWallet.toLowerCase();

                    if (connectedWallet === 'Xverse Wallet') {
                        walletStatusText.textContent = `✅ Xverse Wallet connected! Ready to receive BTC from Starknet. Connect Ready wallet for Starknet operations.`;
                        walletStatusText.style.color = 'var(--secondary)';
                        starknetConnectSection.style.display = 'none';
                    } else if (walletName.includes('ready') || walletName.includes('argent') || walletName.includes('braavos') || window.starknet) {
                        walletStatusText.textContent = `✅ Ready wallet connected! Ready for Starknet operations. Connect Xverse wallet to receive BTC.`;
                        walletStatusText.style.color = 'var(--secondary)';
                        starknetConnectSection.style.display = 'none';
                    } else {
                        walletStatusText.textContent = `✅ ${connectedWallet} connected. For Starknet→Bitcoin bridging, connect both Xverse wallet (to receive BTC) and Ready wallet (for Starknet operations).`;
                        walletStatusText.style.color = 'var(--secondary)';
                        starknetConnectSection.style.display = 'none';
                    }
                } else {
                    walletStatusText.textContent = '💡 For Starknet→Bitcoin bridging: Connect Xverse wallet to receive BTC, and Ready wallet for Starknet operations.';
                    walletStatusText.style.color = 'var(--gray)';
                    starknetConnectSection.style.display = 'none';
                }
            }
        }

        // Remove wallet event listeners
        function removeWalletEventListeners() {
            try {
                if (window.ethereum) {
                    window.ethereum.removeListener('accountsChanged', handleAccountsChanged);
                    window.ethereum.removeListener('chainChanged', handleChainChanged);
                    window.ethereum.removeListener('disconnect', handleDisconnect);
                }

                if (window.starknet) {
                    try {
                        window.starknet.removeListener('accountsChanged', handleStarknetAccountsChanged);
                        window.starknet.removeListener('networkChanged', handleStarknetNetworkChanged);
                    } catch (error) {
                        console.log('Error removing Starknet event listeners:', error);
                    }
                }
            } catch (error) {
                console.log('Error removing event listeners:', error);
            }
        }

        // Use connected wallet address
        function useConnectedAddress() {
            if (connectedAddress) {
                fromAddressInput.value = connectedAddress;
                validateAddress(connectedAddress);
                showNotification('Connected wallet address used');
            } else {
                showNotification('No wallet connected. Please connect a wallet first.', true);
            }
        }

        // Use connected wallet address for To Address
        function useConnectedToAddress() {
            if (connectedAddress) {
                toAddressInput.value = connectedAddress;
                validateToAddress(connectedAddress);
                showNotification('Connected wallet address used for destination');
            } else {
                showNotification('No wallet connected. Please connect a wallet first.', true);
            }
        }

        // Paste address from clipboard
        async function pasteAddress() {
            try {
                if (navigator.clipboard && window.isSecureContext) {
                    const text = await navigator.clipboard.readText();
                    fromAddressInput.value = text.trim();
                    validateAddress(text.trim());
                    showNotification('Address pasted from clipboard');
                } else {
                    showNotification('Please manually paste the address', true);
                }
            } catch (error) {
                console.error('Failed to paste address:', error);
                showNotification('Failed to paste from clipboard. Please paste manually.', true);
            }
        }

        // Paste to address from clipboard
        async function pasteToAddress() {
            try {
                if (navigator.clipboard && window.isSecureContext) {
                    const text = await navigator.clipboard.readText();
                    toAddressInput.value = text.trim();
                    validateToAddress(text.trim());
                    showNotification('Destination address pasted from clipboard');
                } else {
                    showNotification('Please manually paste the address', true);
                }
            } catch (error) {
                console.error('Failed to paste to address:', error);
                showNotification('Failed to paste from clipboard. Please paste manually.', true);
            }
        }

        // Validate address based on current direction
        function validateAddress(address) {
            if (!address) {
                updateValidationMessage('', '');
                return false;
            }

            if (currentDirection === 'to-starknet') {
                // Enhanced Bitcoin address validation for Bitcoin→Starknet
                if (validateBitcoinAddress(address)) {
                    updateValidationMessage('✓ Valid Bitcoin address', 'valid');
                    return true;
                } else {
                    updateValidationMessage('✗ Invalid Bitcoin address format (must be P2PKH, P2SH, or Bech32)', 'invalid');
                    return false;
                }
            } else {
                // Enhanced StarkNet address validation for Starknet→Bitcoin
                if (validateStarknetAddress(address)) {
                    updateValidationMessage('✓ Valid StarkNet address', 'valid');
                    return true;
                } else {
                    updateValidationMessage('✗ Invalid StarkNet address format (must be 0x + 64 hex characters)', 'invalid');
                    return false;
                }
            }
        }

        // Validate to address based on current direction
        function validateToAddress(address) {
            if (!address) {
                updateToAddressValidationMessage('', '');
                return false;
            }

            if (currentDirection === 'to-starknet') {
                // StarkNet address validation for Bitcoin→Starknet
                if (validateStarknetAddress(address)) {
                    updateToAddressValidationMessage('✓ Valid StarkNet address', 'valid');
                    return true;
                } else {
                    updateToAddressValidationMessage('✗ Invalid StarkNet address format (must be 0x + 64 hex characters)', 'invalid');
                    return false;
                }
            } else {
                // Bitcoin address validation for Starknet→Bitcoin
                if (validateBitcoinAddress(address)) {
                    updateToAddressValidationMessage('✓ Valid Bitcoin address', 'valid');
                    return true;
                } else {
                    updateToAddressValidationMessage('✗ Invalid Bitcoin address format', 'invalid');
                    return false;
                }
            }
        }

        // Update validation message display
        function updateValidationMessage(message, type) {
            if (addressValidation) {
                addressValidation.textContent = message;
                addressValidation.className = `address-validation validation-${type}`;
            }

            // Update input border color
            if (fromAddressInput) {
                if (type === 'valid') {
                    fromAddressInput.style.borderColor = 'var(--secondary)';
                } else if (type === 'invalid') {
                    fromAddressInput.style.borderColor = 'var(--danger)';
                } else {
                    fromAddressInput.style.borderColor = 'rgba(255, 255, 255, 0.1)';
                }
            }
        }

        // Update to address validation message display
        function updateToAddressValidationMessage(message, type) {
            if (toAddressValidation) {
                toAddressValidation.textContent = message;
                toAddressValidation.className = `address-validation validation-${type}`;
            }

            // Update input border color
            if (toAddressInput) {
                if (type === 'valid') {
                    toAddressInput.style.borderColor = 'var(--secondary)';
                } else if (type === 'invalid') {
                    toAddressInput.style.borderColor = 'var(--danger)';
                } else {
                    toAddressInput.style.borderColor = 'rgba(255, 255, 255, 0.1)';
                }
            }
        }

        // Validate Starknet address
        function validateStarknetAddress(address) {
            // Must start with 0x and have exactly 64 hex characters (32 bytes for felt252)
            const starknetRegex = /^0x[a-fA-F0-9]{64}$/;
            return starknetRegex.test(address);
        }

        // Validate Bitcoin address
        function validateBitcoinAddress(address) {
            // P2PKH: starts with 1, 25-34 characters
            const p2pkhRegex = /^1[a-km-zA-HJ-NP-Z1-9]{25,34}$/;
            // P2SH: starts with 3, 25-34 characters
            const p2shRegex = /^3[a-km-zA-HJ-NP-Z1-9]{25,34}$/;
            // Bech32: starts with bc1, 11-71 characters after bc1
            const bech32Regex = /^bc1[ac-hj-np-z02-9]{11,71}$/;

            return p2pkhRegex.test(address) || p2shRegex.test(address) || bech32Regex.test(address);
        }

        // Refresh wallet options based on bridge direction
        function refreshWalletOptionsForDirection() {
            console.log(`🔄 Refreshing wallet options for direction: ${currentDirection}`);

            // Update wallet modal title based on direction
            const modalTitle = document.querySelector('.modal-title');
            if (modalTitle) {
                if (currentDirection === 'to-starknet') {
                    modalTitle.textContent = 'Connect Bitcoin Wallet';
                } else {
                    modalTitle.textContent = 'Connect Starknet Wallet';
                }
            }

            // Repopulate wallet options if modal is open
            if (walletModal.style.display === 'flex') {
                populateWalletOptions();
            }

            showNotification(`Wallet options updated for ${currentDirection === 'to-starknet' ? 'Bitcoin' : 'Starknet'} bridge`);
        }

        // Update UI based on selected direction
        function updateUIForDirection() {
            // Hide Starknet connect section when direction changes
            if (starknetConnectSection) {
                starknetConnectSection.style.display = 'none';
            }
            const currencySymbol = document.querySelector('.currency-symbol');
            const balanceInfo = document.querySelector('.balance-info span');
            const bridgeArrow = document.querySelector('.bridge-arrow i');
            const walletStatusText = document.getElementById('walletStatusText');

            if (currentDirection === 'to-starknet') {
                // Bitcoin to Starknet
                currencySymbol.textContent = '₿';
                balanceInfo.textContent = 'Balance: 1.2543 BTC';
                bridgeArrow.className = 'fa-solid fa-arrow-right';
                addressHint.textContent = 'Enter a valid Bitcoin address for Bitcoin→Starknet transfers';
                toAddressHint.textContent = 'Enter a valid StarkNet address for Bitcoin→Starknet transfers';

                document.querySelector('.chain:first-child h3').textContent = 'Bitcoin';
                document.querySelector('.chain:first-child p').textContent = 'Mainnet';
                document.querySelector('.chain:last-child h3').textContent = 'Starknet';
                document.querySelector('.chain:last-child p').textContent = 'Layer 2';

                // Update wallet status for Bitcoin→Starknet
                if (walletStatusText) {
                    if (connectedWallet && connectedAddress) {
                        const walletName = connectedWallet.toLowerCase();
                        const isBitcoinWallet = walletName.includes('trust') || walletName.includes('coinbase') ||
                                              walletName.includes('phantom') || walletName.includes('metamask') || walletName.includes('brave');

                        if (isBitcoinWallet) {
                            walletStatusText.textContent = `✅ Bitcoin wallet connected: ${connectedWallet}. Ready to set destination address and bridge!`;
                            walletStatusText.style.color = 'var(--secondary)';
                        } else {
                            walletStatusText.textContent = `⚠️ Please connect a Bitcoin wallet (Trust Wallet, Coinbase, Phantom) for Bitcoin→Starknet transfers.`;
                            walletStatusText.style.color = 'var(--warning)';
                        }
                    } else {
                        walletStatusText.textContent = '💡 Connect your Bitcoin wallet first (Trust Wallet, Coinbase, Phantom), then your Starknet wallet when ready to bridge.';
                        walletStatusText.style.color = 'var(--gray)';
                    }
                }

                console.log('🔄 UI updated for Bitcoin→Starknet transfer');
            } else {
                // Starknet to Bitcoin
                currencySymbol.textContent = '⧫';
                balanceInfo.textContent = 'Balance: 42.5 STRK';
                bridgeArrow.className = 'fa-solid fa-arrow-left';
                addressHint.textContent = 'Enter a valid StarkNet address for Starknet→Bitcoin transfers';
                toAddressHint.textContent = 'Enter a valid Bitcoin address for Starknet→Bitcoin transfers';

                document.querySelector('.chain:first-child h3').textContent = 'Starknet';
                document.querySelector('.chain:first-child p').textContent = 'Layer 2';
                document.querySelector('.chain:last-child h3').textContent = 'Bitcoin';
                document.querySelector('.chain:last-child p').textContent = 'Mainnet';

                // Update wallet status for Starknet→Bitcoin
                if (walletStatusText) {
                    if (connectedWallet && connectedAddress) {
                        const walletName = connectedWallet.toLowerCase();
                        const isStarknetWallet = walletName.includes('ready') || walletName.includes('argent') || walletName.includes('braavos');

                        if (isStarknetWallet || window.starknet) {
                            walletStatusText.textContent = `✅ Starknet wallet connected: ${connectedWallet}. Ready to bridge!`;
                            walletStatusText.style.color = 'var(--secondary)';
                        } else {
                            walletStatusText.textContent = `⚠️ Please connect a Starknet wallet (Ready Wallet, Argent X, Braavos) for Starknet→Bitcoin transfers.`;
                            walletStatusText.style.color = 'var(--warning)';
                        }
                    } else {
                        walletStatusText.textContent = '💡 Connect your Starknet wallet (Ready Wallet, Argent X, Braavos) to bridge to Bitcoin.';
                        walletStatusText.style.color = 'var(--gray)';
                    }
                }

                console.log('🔄 UI updated for Starknet→Bitcoin transfer');
            }

            // Clear and re-validate if there's a value
            if (fromAddressInput.value) {
                validateAddress(fromAddressInput.value);
            } else {
                updateValidationMessage('', '');
            }

            // Clear and re-validate to address if there's a value
            if (toAddressInput.value) {
                validateToAddress(toAddressInput.value);
            } else {
                updateToAddressValidationMessage('', '');
            }
        }

        // Set maximum amount
        function setMaxAmount() {
            const balanceText = document.querySelector('.balance-info span').textContent;
            const balance = parseFloat(balanceText.match(/(\d+\.\d+)/)[0]);
            const fees = 0.00065; // Network + bridge fees

            // Leave a little for fees if sending from Bitcoin
            const maxAmount = currentDirection === 'to-starknet' ? balance - fees : balance;

            if (bridgeAmount) {
                bridgeAmount.value = maxAmount.toFixed(6);
            }
        }

        // Test wallet functionality before bridge (direction-aware)
        async function testWalletFunctionality() {
            console.log(`🧪 Testing wallet functionality for direction: ${currentDirection}...`);

            if (currentDirection === 'to-starknet') {
                // For Bitcoin→Starknet, we need Starknet wallet for the actual transaction
                if (!window.starknet || (!window.starknet.isConnected && !window.starknet.selectedAddress)) {
                    throw new Error('Starknet wallet not connected. Please connect your Starknet wallet to execute the Bitcoin→Starknet transfer.');
                }

                // Initialize Starknet wallet if needed
                if (!window.starknetBridgeService.account) {
                    console.log('🔄 Initializing Starknet wallet for Bitcoin→Starknet transfer...');
                    await window.starknetBridgeService.initialize('to-starknet');
                }

                if (!window.starknetBridgeService.account) {
                    throw new Error('Failed to initialize Starknet wallet account');
                }
            } else {
                // For Starknet→Bitcoin, ensure we have Starknet wallet
                if (!window.starknetBridgeService.account) {
                    throw new Error('No Starknet wallet account available');
                }
            }

            // Test if we can get the account address
            const address = window.starknetBridgeService.account.address;
            if (!address) {
                throw new Error('Wallet account has no address');
            }

            console.log('✅ Wallet address:', address);

            // Test if execute method exists
            if (!window.starknetBridgeService.account.execute) {
                throw new Error('Wallet account has no execute method');
            }

            console.log('✅ Wallet execute method available');
            return true;
        }

        // Connect Starknet wallet for Bitcoin→Starknet transfers (only when needed)
        async function connectStarknetWalletForBitcoinBridge() {
            if (typeof window.starknet === 'undefined') {
                showNotification('Starknet wallet not detected. Please install Argent X, Braavos, or another Starknet wallet.', true);
                return false;
            }

            try {
                console.log('🔄 Connecting Starknet wallet for Bitcoin→Starknet transfer...');

                // Enable the wallet
                await window.starknet.enable();

                if (!window.starknet.selectedAddress) {
                    throw new Error('No Starknet address available after enabling wallet');
                }

                // Set up the starknet object for the bridge service
                window.starknetBridgeService.provider = window.starknet;
                window.starknetBridgeService.account = {
                    address: window.starknet.selectedAddress,
                    execute: async function(transaction) {
                        return await window.starknet.account.execute(transaction);
                    }
                };

                console.log('✅ Starknet wallet connected successfully');
                showNotification('Starknet wallet connected! Ready to bridge Bitcoin→Starknet.');

                return true;
            } catch (error) {
                console.error('Failed to connect Starknet wallet:', error);
                showNotification(`Starknet wallet connection failed: ${error.message}`, true);
                return false;
            }
        }

        // Transaction state management
        let currentTransaction = {
            isActive: false,
            startTime: null,
            timeoutId: null,
            retryCount: 0,
            maxRetries: 3
        };

        // Initiate bridge transfer with real contract calls (direction-aware)
        async function initiateBridgeTransfer() {
            const amount = parseFloat(bridgeAmount.value);
            const toAddress = toAddressInput.value;
            const fromAddress = fromAddressInput.value.trim();

            // ENHANCED FRONTEND VALIDATION (as suggested by ChatGPT)

            // 1. Validate amount format and range
            if (!amount || isNaN(amount)) {
                showNotification('❌ Invalid amount format. Please enter a valid number.', true);
                return;
            }
            if (amount <= 0) {
                showNotification('❌ Amount must be greater than 0.', true);
                return;
            }
            if (amount < 0.001) {
                showNotification('❌ Minimum bridge amount is 0.001 BTC.', true);
                return;
            }
            if (amount > 10) {
                showNotification('❌ Maximum bridge amount is 10 BTC.', true);
                return;
            }

            // 2. Validate source address
            if (!fromAddress) {
                showNotification('❌ Source address is required.', true);
                return;
            }
            if (!fromAddress.startsWith('0x') && !fromAddress.startsWith('1') && !fromAddress.startsWith('3') && !fromAddress.startsWith('bc1')) {
                showNotification('❌ Invalid source address format.', true);
                return;
            }
            if (!validateAddress(fromAddress)) {
                showNotification('❌ Please enter a valid source address format.', true);
                return;
            }

            // 3. Validate destination address
            if (!toAddress) {
                showNotification('❌ Destination address is required.', true);
                return;
            }
            if (!validateToAddress(toAddress)) {
                showNotification('❌ Please enter a valid destination address format.', true);
                return;
            }

            console.log('✅ Frontend validation passed:', {
                amount,
                fromAddress,
                toAddress,
                direction: currentDirection
            });

            try {
                // Prevent multiple simultaneous transactions
                if (currentTransaction.isActive) {
                    showNotification('Please wait for the current transaction to complete', true);
                    return;
                }

                // Check wallet readiness before starting transaction
                if (!checkWalletReadiness()) {
                    showNotification('Please fix wallet issues before attempting transaction', true);
                    return;
                }

                // Initialize transaction state
                currentTransaction.isActive = true;
                currentTransaction.startTime = Date.now();
                currentTransaction.retryCount = 0;

                // Show enhanced loading state with progress
                bridgeButton.disabled = true;
                bridgeButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Processing Transaction...';

                // Show cancel button
                if (cancelBridgeBtn) {
                    cancelBridgeBtn.style.display = 'block';
                }

                // Start progress animation
                startTransactionProgress();

                let result;

                if (currentDirection === 'to-starknet') {
                    // Bitcoin to Starknet - use Bitcoin wallet for transaction
                    console.log('🔄 Bitcoin to Starknet: Using Bitcoin wallet for transaction...');

                    // For Bitcoin→Starknet, we use the Bitcoin wallet that the user connected
                    // The Bitcoin wallet will handle the transaction signing
                    if (!connectedWallet || !connectedAddress) {
                        showNotification('Please connect your Bitcoin wallet (Xverse Wallet recommended) first.', true);
                        bridgeButton.disabled = false;
                        bridgeButton.innerHTML = '<i class="fas fa-bridge"></i> Bridge Now';
                        return;
                    }

                    // Check if it's a Bitcoin-compatible wallet
                    const walletName = connectedWallet.toLowerCase();
                    const isBitcoinWallet = walletName.includes('trust') || walletName.includes('coinbase') ||
                                          walletName.includes('phantom') || walletName.includes('metamask') || walletName.includes('brave');

                    if (!isBitcoinWallet) {
                        showNotification('Please connect a Bitcoin-compatible wallet for Bitcoin→Starknet transfers.', true);
                        bridgeButton.disabled = false;
                        bridgeButton.innerHTML = '<i class="fas fa-bridge"></i> Bridge Now';
                        return;
                    }

                    console.log('💡 Using Bitcoin wallet for Bitcoin→Starknet transfer:', connectedWallet);

                    // For Bitcoin→Starknet, we'll use a different approach
                    // The Bitcoin wallet provides the source address
                    // The Starknet wallet is needed for smart contract interaction but can be connected later

                    // Check if Starknet wallet is available (but don't require it yet)
                    if (!window.starknet || (!window.starknet.isConnected && !window.starknet.selectedAddress)) {
                        showNotification('Please connect your Starknet wallet (Ready Wallet, Argent X, Braavos) to execute the Bitcoin→Starknet transfer.', true);
                        bridgeButton.disabled = false;
                        bridgeButton.innerHTML = '<i class="fas fa-bridge"></i> Bridge Now';
                        return;
                    }

                    // Initialize Starknet wallet for the smart contract interaction
                    if (!window.starknetBridgeService.account) {
                        console.log('🔄 Initializing Starknet wallet for Bitcoin→Starknet smart contract...');
                        try {
                            await window.starknetBridgeService.initialize('to-starknet');
                        } catch (initError) {
                            console.error('Failed to initialize Starknet wallet:', initError);
                            showNotification(`Starknet wallet initialization failed: ${initError.message}`, true);
                            bridgeButton.disabled = false;
                            bridgeButton.innerHTML = '<i class="fas fa-bridge"></i> Bridge Now';
                            return;
                        }
                    }

                    console.log('Initiating Bitcoin to Starknet deposit...');
                    result = await window.starknetBridgeService.initiateBitcoinDeposit(
                        amount,
                        fromAddress,
                        toAddress
                    );
                    showNotification(`✅ Bitcoin deposit initiated! ${amount} BTC → ${toAddress.substring(0, 10)}... TX: ${result.transactionHash.substring(0, 10)}...`);
                } else {
                    // Starknet to Bitcoin - ensure Starknet wallet is connected for transaction execution
                    if (!window.starknet || (!window.starknet.isConnected && !window.starknet.selectedAddress)) {
                        showNotification('Please connect your Starknet wallet (Ready Wallet, Argent X, Braavos) to execute the Starknet→Bitcoin transfer.', true);
                        bridgeButton.disabled = false;
                        bridgeButton.innerHTML = '<i class="fas fa-bridge"></i> Bridge Now';
                        return;
                    }

                    // Initialize Starknet wallet for the smart contract interaction
                    if (!window.starknetBridgeService.account) {
                        console.log('🔄 Initializing Starknet wallet for Starknet→Bitcoin smart contract...');
                        try {
                            await window.starknetBridgeService.initialize('to-bitcoin');
                        } catch (initError) {
                            console.error('Failed to initialize Starknet wallet:', initError);
                            showNotification(`Starknet wallet initialization failed: ${initError.message}`, true);
                            bridgeButton.disabled = false;
                            bridgeButton.innerHTML = '<i class="fas fa-bridge"></i> Bridge Now';
                            return;
                        }
                    }

                    console.log('Initiating Starknet to Bitcoin withdrawal...');
                    result = await window.starknetBridgeService.initiateBitcoinWithdrawal(
                        amount,
                        toAddress
                    );
                    showNotification(`✅ Bitcoin withdrawal initiated! ${amount} BTC → ${toAddress.substring(0, 10)}... TX: ${result.transactionHash.substring(0, 10)}...`);
                }

                // Reset form
                bridgeForm.reset();
                updateValidationMessage('', '');
                updateToAddressValidationMessage('', '');

                // Update transaction status with real data
                updateTransactionStatus({
                    amount: amount,
                    fromAddress: fromAddress,
                    toAddress: toAddress,
                    transactionHash: result.transactionHash
                });

                // Start progress simulation
                startBridgeProgress();

            } catch (error) {
                console.error('Bridge transfer error:', error);

                // Consolidated enhanced error handling for specific issues
                const msg = error && error.message ? error.message : '';

                if (msg.includes('timeout')) {
                    showNotification('⏰ Transaction timed out. This is normal for Starknet - the transaction may still succeed. Please check your wallet or try again.', true);

                    // Offer to retry after a timeout
                    setTimeout(() => {
                        if (confirm('Would you like to retry the transaction?')) {
                            initiateBridgeTransfer();
                        }
                    }, 3000);
                } else if (msg.includes('Invalid calldata')) {
                    showNotification('❌ Transaction data format error. Please check your addresses and try again.', true);
                    console.log('💡 Try running debugBridgeTransaction() in console to test your specific values');
                } else if (msg.includes('rejected') || msg.includes('User denied')) {
                    showNotification('❌ Transaction rejected by wallet. Please try again.', true);
                } else if (msg.includes('insufficient') || msg.includes('balance')) {
                    showNotification('❌ Insufficient balance for this transaction.', true);
                } else if (msg.includes('nonce')) {
                    showNotification('❌ Transaction nonce error. Please reset your wallet and try again.', true);
                } else if (msg.includes('network') || msg.includes('Network')) {
                    showNotification('❌ Network error. Please check your connection and try again.', true);
                } else {
                    // Fallback to generic contract error handler
                    handleContractError(error, 'Bridge transfer');
                }
            } finally {
                // Clean up transaction state
                cleanupTransaction();

                // Reset button state with delay to show user feedback
                setTimeout(() => {
                    bridgeButton.disabled = false;
                    bridgeButton.innerHTML = '<i class="fas fa-bridge"></i> Bridge Now';
                }, 1000);
            }
        }

        // Update transaction status with real data
        function updateTransactionStatus(result) {
            const txHashElement = document.querySelector('.transaction-hash');

            if (txHashElement) {
                // Use real transaction hash if available, otherwise generate mock
                const txHash = result.transactionHash || ('0x' + Array.from({length: 64}, () =>
                    Math.floor(Math.random() * 16).toString(16)).join(''));

                txHashElement.textContent = txHash;
                txHashElement.onclick = () => copyTransactionHash(txHashElement);
            }

            // Update amount display
            const amountElement = document.querySelector('.transaction-status .fee-item:nth-child(2) span:last-child');
            if (amountElement) {
                amountElement.textContent = `${result.amount} ${currentDirection === 'to-starknet' ? 'BTC' : 'STRK'}`;
            }

            // Update progress
            if (progressFill) progressFill.style.width = '10%';
            if (progressValue) progressValue.textContent = '10%';

            // Update status indicator
            const statusDot = document.querySelector('.status-dot');
            const statusText = document.querySelector('.status-indicator span');
            if (statusDot && statusText) {
                statusDot.className = 'status-dot status-processing';
                statusText.textContent = 'Processing';
            }
        }

        // Transaction progress and state management functions
        function startTransactionProgress() {
            let progress = 0;
            const progressInterval = setInterval(() => {
                progress += 2; // Slower progress for longer transactions
                if (progress > 95) progress = 95; // Don't complete until transaction is done

                if (progressFill) progressFill.style.width = `${progress}%`;
                if (progressValue) progressValue.textContent = `${progress}%`;

                // Update elapsed time
                updateTransactionElapsedTime();

                // Check if transaction is taking too long
                if (currentTransaction.isActive && Date.now() - currentTransaction.startTime > 180000) { // 3 minutes
                    console.warn('Transaction is taking longer than expected...');
                    showNotification('Transaction is taking longer than usual. Please check your wallet.', true);
                }
            }, 1000);

            // Store interval for cleanup
            currentTransaction.progressInterval = progressInterval;
        }

        function updateTransactionElapsedTime() {
            if (!currentTransaction.isActive || !currentTransaction.startTime) return;

            const elapsed = Math.floor((Date.now() - currentTransaction.startTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;

            // Update UI with elapsed time if element exists
            const elapsedElement = document.getElementById('transactionElapsed');
            if (elapsedElement) {
                elapsedElement.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }
        }

        function cleanupTransaction() {
            // Clear any existing timeouts
            if (currentTransaction.timeoutId) {
                clearTimeout(currentTransaction.timeoutId);
                currentTransaction.timeoutId = null;
            }

            // Clear progress interval
            if (currentTransaction.progressInterval) {
                clearInterval(currentTransaction.progressInterval);
                currentTransaction.progressInterval = null;
            }

            // Hide cancel button
            if (cancelBridgeBtn) {
                cancelBridgeBtn.style.display = 'none';
            }

            // Reset transaction state
            currentTransaction.isActive = false;
            currentTransaction.startTime = null;
            currentTransaction.retryCount = 0;
        }

        function showTransactionProgress() {
            // Create or update transaction progress overlay
            let progressOverlay = document.getElementById('transactionProgressOverlay');
            if (!progressOverlay) {
                progressOverlay = document.createElement('div');
                progressOverlay.id = 'transactionProgressOverlay';
                progressOverlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.8);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 9999;
                    backdrop-filter: blur(5px);
                `;
                progressOverlay.innerHTML = `
                    <div style="background: rgba(15, 23, 42, 0.9); padding: 30px; border-radius: 16px; text-align: center; border: 1px solid rgba(124, 58, 237, 0.3);">
                        <div style="margin-bottom: 20px;">
                            <i class="fas fa-spinner fa-spin" style="font-size: 3rem; color: var(--primary);"></i>
                        </div>
                        <h3 style="color: var(--primary); margin-bottom: 10px;">Processing Transaction</h3>
                        <p style="color: var(--gray); margin-bottom: 15px;">Please check your wallet and confirm the transaction</p>
                        <div style="display: flex; justify-content: center; gap: 20px; margin-bottom: 15px;">
                            <div>
                                <div style="font-size: 0.9rem; color: var(--gray);">Progress</div>
                                <div id="progressText" style="font-size: 1.2rem; font-weight: 600; color: var(--primary);">0%</div>
                            </div>
                            <div>
                                <div style="font-size: 0.9rem; color: var(--gray);">Elapsed</div>
                                <div id="elapsedText" style="font-size: 1.2rem; font-weight: 600; color: var(--primary);">0:00</div>
                            </div>
                        </div>
                        <div style="width: 300px; height: 8px; background: rgba(255,255,255,0.1); border-radius: 4px; overflow: hidden;">
                            <div id="progressBar" style="width: 0%; height: 100%; background: linear-gradient(90deg, var(--primary), var(--primary-light)); transition: width 0.5s ease;"></div>
                        </div>
                        <button onclick="cancelCurrentTransaction()" style="margin-top: 20px; padding: 10px 20px; background: rgba(239, 68, 68, 0.2); border: 1px solid var(--danger); color: var(--danger); border-radius: 8px; cursor: pointer;">Cancel Transaction</button>
                    </div>
                `;
                document.body.appendChild(progressOverlay);
            }

            // Update progress values
            setInterval(() => {
                const progress = progressFill ? parseInt(progressFill.style.width) || 0 : 0;
                const progressText = document.getElementById('progressText');
                const progressBar = document.getElementById('progressBar');
                const elapsedText = document.getElementById('elapsedText');

                if (progressText) progressText.textContent = `${progress}%`;
                if (progressBar) progressBar.style.width = `${progress}%`;

                if (currentTransaction.isActive && currentTransaction.startTime) {
                    const elapsed = Math.floor((Date.now() - currentTransaction.startTime) / 1000);
                    const minutes = Math.floor(elapsed / 60);
                    const seconds = elapsed % 60;
                    if (elapsedText) elapsedText.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                }
            }, 1000);

            progressOverlay.style.display = 'flex';
        }

        function hideTransactionProgress() {
            const progressOverlay = document.getElementById('transactionProgressOverlay');
            if (progressOverlay) {
                progressOverlay.style.display = 'none';
            }
        }

        function cancelCurrentTransaction() {
            if (currentTransaction.isActive) {
                cleanupTransaction();
                hideTransactionProgress();
                showNotification('Transaction cancelled by user');

                // Reset button state
                const bridgeButton = document.getElementById('bridgeButton');
                if (bridgeButton) {
                    bridgeButton.disabled = false;
                    bridgeButton.innerHTML = '<i class="fas fa-bridge"></i> Bridge Now';
                }
            }
        }

        // Start bridge progress simulation (updated)
        function startBridgeProgress() {
            let progress = 10;

            // Show progress overlay for better UX
            showTransactionProgress();

            const interval = setInterval(() => {
                progress += 3; // Slower, more realistic progress

                if (progress > 100) {
                    progress = 100;
                    clearInterval(interval);
                    hideTransactionProgress();
                    showNotification('Bridge transfer completed! Funds have arrived.');

                    // Update status indicator
                    const statusDot = document.querySelector('.status-dot');
                    const statusText = document.querySelector('.status-indicator span');
                    if (statusDot) statusDot.className = 'status-dot status-confirmed';
                    if (statusText) statusText.textContent = 'Completed';
                }

                if (progressFill) progressFill.style.width = `${progress}%`;
                if (progressValue) progressValue.textContent = `${progress}%`;
            }, 3000); // Longer intervals for more realistic feel
        }

        // Copy transaction hash to clipboard
        async function copyTransactionHash(element) {
            const hashText = element.textContent.trim();

            try {
                if (navigator.clipboard && window.isSecureContext) {
                    await navigator.clipboard.writeText(hashText);
                } else {
                    // Fallback for older browsers
                    const textArea = document.createElement('textarea');
                    textArea.value = hashText;
                    textArea.style.position = 'fixed';
                    textArea.style.left = '-999999px';
                    textArea.style.top = '-999999px';
                    document.body.appendChild(textArea);
                    textArea.focus();
                    textArea.select();
                    document.execCommand('copy');
                    textArea.remove();
                }

                // Visual feedback
                const copyBtn = element.nextElementSibling;
                if (copyBtn && copyBtn.classList.contains('copy-hash-btn')) {
                    copyBtn.classList.add('copied');
                    setTimeout(() => {
                        copyBtn.classList.remove('copied');
                    }, 2000);
                }

                showNotification('Transaction hash copied to clipboard!', false);

            } catch (error) {
                console.error('Failed to copy transaction hash:', error);
                showNotification('Failed to copy transaction hash. Please copy manually.', true);
            }
        }

        // Real staking functions with contract integration
        async function stakeTokens(amount) {
            if (!ensureWalletConnected()) {
                return;
            }

            if (!amount || parseFloat(amount) <= 0) {
                showNotification('Please enter a valid staking amount', true);
                return;
            }

            if (parseFloat(amount) < 0.001) {
                showNotification('Minimum staking amount is 0.001 SBTC', true);
                return;
            }

            try {
                // Show loading state
                stakeBtn.disabled = true;
                stakeBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Staking...';

                const sbtcAddress = BRIDGE_CONFIG.TOKENS.SBTC.address;
                console.log('Staking tokens:', { amount, sbtcAddress });

                const result = await window.starknetBridgeService.stakeTokens(sbtcAddress, amount);

                showNotification(`✅ Staked ${amount} SBTC successfully! TX: ${result.transactionHash.substring(0, 10)}...`);

                // Reload staking data from contract
                await loadStakingData();

                // Update UI with real data
                updateStakingUI();

            } catch (error) {
                console.error('Staking error:', error);
                handleContractError(error, 'Staking');
            } finally {
                // Reset button state
                stakeBtn.disabled = false;
                stakeBtn.innerHTML = '<i class="fas fa-plus"></i> Stake';
            }
        }

        async function unstakeTokens(amount) {
            if (!ensureWalletConnected()) {
                return;
            }

            if (!amount || parseFloat(amount) <= 0) {
                showNotification('Please enter a valid unstaking amount', true);
                return;
            }

            if (parseFloat(amount) > bridgeState.stakingData.stakedAmount) {
                showNotification('Cannot unstake more than your staked amount', true);
                return;
            }

            try {
                // Show loading state
                unstakeBtn.disabled = true;
                unstakeBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Unstaking...';

                const sbtcAddress = BRIDGE_CONFIG.TOKENS.SBTC.address;
                console.log('Unstaking tokens:', { amount, sbtcAddress });

                const result = await window.starknetBridgeService.unstakeTokens(sbtcAddress, amount);

                showNotification(`✅ Unstaked ${amount} SBTC successfully! TX: ${result.transactionHash.substring(0, 10)}...`);

                // Reload staking data from contract
                await loadStakingData();

                // Update UI with real data
                updateStakingUI();

            } catch (error) {
                console.error('Unstaking error:', error);
                handleContractError(error, 'Unstaking');
            } finally {
                // Reset button state
                unstakeBtn.disabled = false;
                unstakeBtn.innerHTML = '<i class="fas fa-minus"></i> Unstake';
            }
        }

        async function claimStakingRewards() {
            if (!ensureWalletConnected()) {
                return;
            }

            if (bridgeState.stakingData.rewards <= 0) {
                showNotification('No rewards available to claim', true);
                return;
            }

            try {
                // Show loading state
                claimRewardsBtn.disabled = true;
                claimRewardsBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Claiming...';

                const sbtcAddress = BRIDGE_CONFIG.TOKENS.SBTC.address;
                console.log('Claiming rewards for:', sbtcAddress);

                const result = await window.starknetBridgeService.claimRewards(sbtcAddress);

                showNotification(`✅ Rewards claimed successfully! TX: ${result.transactionHash.substring(0, 10)}...`);

                // Reload staking data from contract
                await loadStakingData();

                // Update UI with real data
                updateStakingUI();

            } catch (error) {
                console.error('Claim rewards error:', error);
                handleContractError(error, 'Claim rewards');
            } finally {
                // Reset button state
                claimRewardsBtn.disabled = false;
                claimRewardsBtn.innerHTML = '<i class="fas fa-gift"></i> Claim Rewards';
            }
        }

        // Show notification
        function showNotification(message, isError = false) {
            notificationText.textContent = message;

            if (isError) {
                notification.style.borderLeftColor = '#f44336';
            } else {
                notification.style.borderLeftColor = '#ff2c6e';
            }

            notification.style.display = 'block';

            setTimeout(() => {
                notification.style.display = 'none';
            }, 3000);
        }

        // Add test function for bridge functionality
        window.testBridgeIntegration = async function() {
            console.log('🧪 Testing Bridge Integration...');

            try {
                // Test 1: Check if service is available
                if (typeof window.starknetBridgeService === 'undefined') {
                    throw new Error('Bridge service not loaded');
                }
                console.log('✅ Bridge service loaded');

                // Test 2: Check contract address configuration
                if (!BRIDGE_CONFIG.BRIDGE_CONTRACT) {
                    throw new Error('Bridge contract address not configured');
                }
                console.log('✅ Contract address configured:', BRIDGE_CONFIG.BRIDGE_CONTRACT);

                // Test 3: Try to initialize service (will fail without wallet, but should not crash)
                try {
                    await window.starknetBridgeService.initialize();
                    console.log('✅ Bridge service initialized successfully');
                } catch (initError) {
                    if (initError.message.includes('Starknet wallet not detected') ||
                        initError.message.includes('not connected')) {
                        console.log('⚠️ Bridge service needs wallet connection (expected)');
                    } else {
                        throw initError;
                    }
                }

                // Test 4: Validate address conversion functions
                try {
                    const btcAddress = '1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa';
                    const starknetAddress = '0x1234567890abcdef';

                    const btcFelt = window.starknetBridgeService.bitcoinAddressToFelt(btcAddress);
                    const starkFelt = window.starknetBridgeService.starknetAddressToFelt(starknetAddress);

                    console.log('✅ Address conversion functions working');
                    console.log('Bitcoin address:', btcAddress);
                    console.log('Bitcoin address felt:', btcFelt);
                    console.log('Starknet address:', starknetAddress);
                    console.log('Starknet address felt:', starkFelt);

                    // Test calldata validation
                    const testCalldata = ['123', '0', btcFelt, starkFelt];
                    window.starknetBridgeService.validateCalldata(testCalldata);
                    console.log('✅ Calldata validation working');
                } catch (conversionError) {
                    console.error('❌ Address conversion failed:', conversionError);
                    throw new Error('Address conversion failed: ' + conversionError.message);
                }

                console.log('🎉 Bridge integration test completed successfully!');
                showNotification('Bridge integration test passed!');

            } catch (error) {
                console.error('❌ Bridge integration test failed:', error);
                showNotification(`Bridge test failed: ${error.message}`, true);
            }
        };

        // Debug function to test specific bridge transaction
        window.debugBridgeTransaction = async function(amount, btcAddress, starknetAddress) {
            console.log('🔍 Debugging Bridge Transaction...');
            console.log('Input parameters:', { amount, btcAddress, starknetAddress });

            try {
                // Test address conversion
                const btcFelt = window.starknetBridgeService.bitcoinAddressToFelt(btcAddress);
                const starknetFelt = window.starknetBridgeService.starknetAddressToFelt(starknetAddress);
                const amountU256 = window.starknetBridgeService.btcToSatoshis(amount);

                console.log('Converted values:', {
                    btcFelt: btcFelt,
                    starknetFelt: starknetFelt,
                    amountU256: amountU256
                });

                // Test calldata
                const calldata = [amountU256.low, amountU256.high, btcFelt, starknetFelt];
                console.log('Calldata array:', calldata);
                console.log('Calldata types:', calldata.map((item, i) => `${i}: ${typeof item} = "${item}"`));

                // Validate calldata
                window.starknetBridgeService.validateCalldata(calldata);
                console.log('✅ Calldata validation passed');

                // Test wallet account if available
                if (window.starknetBridgeService.account) {
                    console.log('Wallet account available:', window.starknetBridgeService.account);
                    console.log('Account has execute method:', typeof window.starknetBridgeService.account.execute);
                } else {
                    console.log('⚠️ No wallet account available for testing');
                }

                return {
                    success: true,
                    calldata: calldata,
                    converted: {
                        btcFelt,
                        starknetFelt,
                        amountU256
                    },
                    walletInfo: window.starknetBridgeService.account ? {
                        hasExecute: !!window.starknetBridgeService.account.execute,
                        address: window.starknetBridgeService.account.address || 'unknown'
                    } : null
                };

            } catch (error) {
                console.error('❌ Debug failed:', error);
                console.error('Error details:', {
                    message: error.message,
                    stack: error.stack,
                    name: error.name
                });
                return {
                    success: false,
                    error: error.message,
                    errorDetails: error,
                    calldata: null
                };
            }
        };

        // Test with your exact parameters
        window.testYourTransaction = async function() {
            console.log('🧪 Testing your exact transaction parameters...');
            const amount = 0.1;
            const btcAddress = '1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa'; // Example BTC address
            const starknetAddress = '0x1234567890abcdef'; // Example Starknet address

            return await debugBridgeTransaction(amount, btcAddress, starknetAddress);
        };

        // Test with real addresses (replace with your actual addresses)
        window.testRealTransaction = async function(amount = 0.1, btcAddress = '1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa', starknetAddress = '0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef') {
            console.log('🧪 Testing with real addresses...');
            console.log('Testing parameters:', { amount, btcAddress, starknetAddress });

            // Validate addresses first
            if (!validateBitcoinAddress(btcAddress)) {
                console.error('❌ Invalid Bitcoin address:', btcAddress);
                showNotification(`Invalid Bitcoin address: ${btcAddress}`, true);
                return;
            }

            if (!validateStarknetAddress(starknetAddress)) {
                console.error('❌ Invalid Starknet address:', starknetAddress);
                showNotification(`Invalid Starknet address: ${starknetAddress}`, true);
                return;
            }

            return await debugBridgeTransaction(amount, btcAddress, starknetAddress);
        };

        // Test Starknet to Bitcoin withdrawal specifically
        window.testStarknetToBitcoin = async function(amount = 0.1, btcAddress = '1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa') {
            console.log('🧪 Testing Starknet → Bitcoin Withdrawal...');
            console.log('Testing withdrawal parameters:', { amount, btcAddress });

            try {
                // Validate Bitcoin address
                if (!validateBitcoinAddress(btcAddress)) {
                    console.error('❌ Invalid Bitcoin address:', btcAddress);
                    showNotification(`Invalid Bitcoin address: ${btcAddress}`, true);
                    return;
                }

                // Test address conversion for withdrawal
                const btcFelt = window.starknetBridgeService.bitcoinAddressToFelt(btcAddress);
                const amountU256 = window.starknetBridgeService.btcToSatoshis(amount);

                console.log('✅ Withdrawal conversion successful:', {
                    btcFelt: btcFelt,
                    amountU256: amountU256
                });

                // Test withdrawal calldata
                const withdrawalCalldata = [
                    String(amountU256.low),
                    String(amountU256.high),
                    btcFelt
                ];

                console.log('Withdrawal calldata array:', withdrawalCalldata);
                console.log('Withdrawal calldata details:', withdrawalCalldata.map((item, i) => ({
                    index: i,
                    value: item,
                    type: typeof item,
                    length: item.length,
                    format: item.startsWith('0x') ? 'hex' : 'decimal'
                })));

                // Validate withdrawal calldata
                window.starknetBridgeService.validateCalldata(withdrawalCalldata);
                console.log('✅ Withdrawal calldata validation passed');

                return {
                    success: true,
                    withdrawalCalldata: withdrawalCalldata,
                    conversions: {
                        btcFelt,
                        amountU256
                    }
                };

            } catch (error) {
                console.error('❌ Starknet to Bitcoin test failed:', error);
                return {
                    success: false,
                    error: error.message,
                    errorDetails: error
                };
            }
        };

        // Test Bitcoin to Starknet deposit specifically
        window.testBitcoinToStarknet = async function(amount = 0.1, btcAddress = '1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa', starknetAddress = '0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef') {
            console.log('🧪 Testing Bitcoin → Starknet Deposit...');
            console.log('Testing deposit parameters:', { amount, btcAddress, starknetAddress });

            try {
                // Validate addresses
                if (!validateBitcoinAddress(btcAddress)) {
                    console.error('❌ Invalid Bitcoin address:', btcAddress);
                    showNotification(`Invalid Bitcoin address: ${btcAddress}`, true);
                    return;
                }

                if (!validateStarknetAddress(starknetAddress)) {
                    console.error('❌ Invalid Starknet address:', starknetAddress);
                    showNotification(`Invalid Starknet address: ${starknetAddress}`, true);
                    return;
                }

                // Test address conversion for deposit
                const btcFelt = window.starknetBridgeService.bitcoinAddressToFelt(btcAddress);
                const starknetFelt = window.starknetBridgeService.starknetAddressToFelt(starknetAddress);
                const amountU256 = window.starknetBridgeService.btcToSatoshis(amount);

                console.log('✅ Deposit conversion successful:', {
                    btcFelt: btcFelt,
                    starknetFelt: starknetFelt,
                    amountU256: amountU256
                });

                // Test deposit calldata
                const depositCalldata = [
                    String(amountU256.low),
                    String(amountU256.high),
                    btcFelt,
                    starknetFelt
                ];

                console.log('Deposit calldata array:', depositCalldata);
                console.log('Deposit calldata details:', depositCalldata.map((item, i) => ({
                    index: i,
                    value: item,
                    type: typeof item,
                    length: item.length,
                    format: item.startsWith('0x') ? 'hex' : 'decimal'
                })));

                // Validate deposit calldata
                window.starknetBridgeService.validateCalldata(depositCalldata);
                console.log('✅ Deposit calldata validation passed');

                return {
                    success: true,
                    depositCalldata: depositCalldata,
                    conversions: {
                        btcFelt,
                        starknetFelt,
                        amountU256
                    }
                };

            } catch (error) {
                console.error('❌ Bitcoin to Starknet test failed:', error);
                return {
                    success: false,
                    error: error.message,
                    errorDetails: error
                };
            }
        };

        // Initialize the application
        init();

        // Add testing functions for bridge directions
        window.testBridgeDirections = function() {
            console.log('🧪 Testing Bridge Direction Logic...');

            // Test Bitcoin→Starknet direction
            console.log('\n🔄 Testing Bitcoin→Starknet Direction:');
            currentDirection = 'to-starknet';
            updateUIForDirection();
            updateWalletStatusDisplay();

            const btcWallets = getAvailableWallets();
            console.log(`Available wallets for Bitcoin→Starknet: ${btcWallets.length}`);
            btcWallets.forEach((wallet, i) => {
                console.log(`  ${i+1}. ${wallet.name} (${wallet.type})`);
            });

            // Test Starknet→Bitcoin direction
            console.log('\n🔄 Testing Starknet→Bitcoin Direction:');
            currentDirection = 'to-bitcoin';
            updateUIForDirection();
            updateWalletStatusDisplay();

            const starknetWallets = getAvailableWallets();
            console.log(`Available wallets for Starknet→Bitcoin: ${starknetWallets.length}`);
            starknetWallets.forEach((wallet, i) => {
                console.log(`  ${i+1}. ${wallet.name} (${wallet.type})`);
            });

            console.log('\n✅ Bridge direction logic test completed');
            console.log('💡 Summary:');
            console.log('  - Bitcoin→Starknet: Bitcoin wallet for UI, Starknet wallet for execution');
            console.log('  - Starknet→Bitcoin: Bitcoin wallet for destination, Starknet wallet for execution');

            return {
                success: true,
                bitcoinToStarknet: {
                    direction: 'to-starknet',
                    walletCount: btcWallets.length,
                    primaryWalletType: 'Bitcoin'
                },
                starknetToBitcoin: {
                    direction: 'to-bitcoin',
                    walletCount: starknetWallets.length,
                    primaryWalletType: 'Bitcoin (destination)'
                }
            };
        };

        // Run test after a short delay to ensure everything is loaded
        setTimeout(() => {
            console.log('🔧 Bridge system ready for testing');
            console.log('💡 To test the bridge, connect your wallet and try a transaction');
            console.log('🔍 Debug commands available:');
            console.log('  - testBridgeIntegration()');
            console.log('  - debugBridgeTransaction(amount, btcAddress, starknetAddress)');
            console.log('  - testBitcoinToStarknet()');
            console.log('  - testStarknetToBitcoin()');
            console.log('  - testBitcoinToStarknetBridge()');
            console.log('  - testBitcoinAddressLengthConversion()');
            console.log('  - refreshWalletDetection()');
            console.log('  - showAllWallets()');
            console.log('  - debugWalletConnection()');
            console.log('  - testWalletButtons() - Test new wallet connect buttons');
            console.log('  - debugXverseWallet() - Debug Xverse wallet specifically');
            console.log('  - testArgentMulticallFix() - Test the Argent multicall fix');

            // Auto-run wallet button test
            console.log('🧪 Auto-testing wallet connect buttons...');
            testWalletButtons();

            // Auto-run Argent multicall fix test
            console.log('🧪 Auto-testing Argent multicall fix...');
            if (typeof testArgentMulticallFix === 'function') {
                testArgentMulticallFix();
            }
        }, 2000);

        // Test function for Argent multicall fix
        window.testArgentMulticallFix = function() {
            console.log('🧪 Testing Argent Multicall Fix...');

            if (window.starknetBridgeService) {
                console.log('✅ Bridge service loaded');

                // Check if wallet is connected
                if (window.starknetBridgeService.account) {
                    console.log('✅ Wallet account available');

                    // Check execution methods
                    console.log('🔍 Available execution methods:');
                    console.log('  - Direct wallet execution:', !!(window.starknet && window.starknet.account && window.starknet.account.execute));
                    console.log('  - Account.execute:', !!(window.starknetBridgeService.account && window.starknetBridgeService.account.execute));
                    console.log('  - Provider available:', !!window.starknetBridgeService.provider);

                    console.log('💡 The fix should bypass Argent\'s multicall system');
                    console.log('💡 Try your bridge transaction now - it should work without the ENTRYPOINT_NOT_FOUND error');

                } else {
                    console.log('⚠️ No wallet account connected');
                    console.log('💡 Connect your Ready wallet first, then try the bridge transaction');
                }
            } else {
                console.log('❌ Bridge service not loaded');
                console.log('💡 Refresh the page to load the updated bridge service');
            }

            return {
                serviceLoaded: !!window.starknetBridgeService,
                walletConnected: !!(window.starknetBridgeService && window.starknetBridgeService.account),
                directExecution: !!(window.starknet && window.starknet.account && window.starknet.account.execute),
                accountExecute: !!(window.starknetBridgeService && window.starknetBridgeService.account && window.starknetBridgeService.account.execute),
                providerAvailable: !!(window.starknetBridgeService && window.starknetBridgeService.provider)
            };
        };

        // Test function for wallet connect buttons
        window.testWalletButtons = function() {
            console.log('🧪 Testing Wallet Connect Buttons...');

            // Check if buttons exist in DOM
            const xverseBtn = document.getElementById('connectXverseBtn');
            const readyBtn = document.getElementById('connectReadyBtn');

            console.log('Xverse button found:', !!xverseBtn);
            console.log('Ready button found:', !!readyBtn);

            if (xverseBtn) {
                console.log('✅ Xverse button HTML:', xverseBtn.outerHTML.substring(0, 100) + '...');
                console.log('✅ Xverse button has click listener:', !!xverseBtn.onclick);
            }

            if (readyBtn) {
                console.log('✅ Ready button HTML:', readyBtn.outerHTML.substring(0, 100) + '...');
                console.log('✅ Ready button has click listener:', !!readyBtn.onclick);
            }

            // Test wallet availability
            console.log('\n📋 Testing wallet availability for Starknet→Bitcoin direction:');
            currentDirection = 'to-bitcoin';
            const wallets = getAvailableWallets();

            console.log(`Found ${wallets.length} wallets for Starknet→Bitcoin:`);
            wallets.forEach((wallet, i) => {
                const isAvailable = wallet.isAvailable();
                console.log(`  ${i+1}. ${wallet.name} (${wallet.type}) - ${isAvailable ? '✅ Available' : '❌ Not Available'}`);

                if (wallet.id === 'xverse' || wallet.id === 'starknet') {
                    console.log(`     💡 This is a ${wallet.id === 'xverse' ? 'Xverse' : 'Ready'} wallet - should have dedicated button`);
                }
            });

            // Test specific wallet connection functions
            console.log('\n🔧 Testing specific wallet connection functions:');
            console.log('connectToSpecificWallet function exists:', typeof connectToSpecificWallet === 'function');

            // Test wallet status display update
            console.log('\n🎨 Testing wallet status display:');
            updateWalletStatusDisplay();

            const statusText = document.getElementById('walletStatusText');
            if (statusText) {
                console.log('✅ Wallet status display updated');
                console.log('Current status text:', statusText.textContent.substring(0, 100) + '...');
            }

            console.log('\n🎉 Wallet connect buttons test completed!');
            console.log('💡 To test actual wallet connections:');
            console.log('  1. Open browser to http://localhost:8000/Bridge.html');
            console.log('  2. Click "Starknet to Bitcoin" direction');
            console.log('  3. Try clicking "Connect Xverse Wallet" and "Connect Ready Wallet" buttons');
            console.log('  4. Check console for connection logs');

            return {
                xverseButtonExists: !!xverseBtn,
                readyButtonExists: !!readyBtn,
                xverseButtonHasListener: !!(xverseBtn && xverseBtn.onclick),
                readyButtonHasListener: !!(readyBtn && readyBtn.onclick),
                walletCount: wallets.length,
                availableWallets: wallets.filter(w => w.isAvailable()).length
            };
        };

        // Check wallet readiness for transactions
        function checkWalletReadiness() {
            console.log('🔍 Checking wallet readiness for transactions...');

            const issues = [];

            // Check if wallet is connected
            if (!connectedAddress) {
                issues.push('No wallet connected');
            }

            // Check wallet type compatibility
            if (connectedWallet) {
                const walletName = connectedWallet.toLowerCase();
                if (currentDirection === 'to-starknet') {
                    const isBitcoinWallet = walletName.includes('trust') || walletName.includes('coinbase') ||
                                          walletName.includes('phantom') || walletName.includes('metamask') ||
                                          walletName.includes('brave') || walletName.includes('wallet') || window.ethereum;

                    if (!isBitcoinWallet) {
                        issues.push('Bitcoin wallet may not be compatible');
                    }
                } else {
                    const isStarknetWallet = walletName.includes('ready') || walletName.includes('argent') ||
                                           walletName.includes('braavos') || walletName.includes('starknet') || window.starknet;

                    if (!isStarknetWallet) {
                        issues.push('Starknet wallet may not be compatible');
                    }
                }
            }

            // Check network connection
            if (!navigator.onLine) {
                issues.push('No internet connection');
            }

            // Check if required wallet objects exist
            if (currentDirection === 'to-starknet' && (!window.starknet || !window.starknet.account)) {
                issues.push('Starknet wallet not properly initialized');
            }

            if (issues.length > 0) {
                console.warn('⚠️ Wallet readiness issues found:', issues);
                showNotification(`Wallet issues detected: ${issues.join(', ')}. This may cause transaction timeouts.`, true);
                return false;
            }

            console.log('✅ Wallet readiness check passed');
            return true;
        }

        // Add wallet debugging function
        window.debugWalletConnection = function() {
            console.log('🔍 Wallet Connection Debug');
            console.log('========================');

            // Check global wallet objects
            console.log('window.ethereum:', !!window.ethereum);
            console.log('window.starknet:', !!window.starknet);
            console.log('window.solana:', !!window.solana);
            console.log('window.trustwallet:', !!window.trustwallet);
            console.log('window.xverse:', !!window.xverse);

            if (window.ethereum) {
                console.log('Ethereum provider details:', {
                    isMetaMask: window.ethereum.isMetaMask,
                    isTrust: window.ethereum.isTrust,
                    isCoinbaseWallet: window.ethereum.isCoinbaseWallet,
                    isBraveWallet: window.ethereum.isBraveWallet,
                    isXverse: window.ethereum.isXverse,
                    selectedAddress: window.ethereum.selectedAddress,
                    chainId: window.ethereum.chainId,
                    constructorName: window.ethereum.constructor?.name
                });

                if (window.ethereum.providers && Array.isArray(window.ethereum.providers)) {
                    console.log('Ethereum providers array:');
                    window.ethereum.providers.forEach((p, i) => {
                        console.log(`  Provider ${i}:`, {
                            isMetaMask: p.isMetaMask,
                            isTrust: p.isTrust,
                            isCoinbaseWallet: p.isCoinbaseWallet,
                            isBraveWallet: p.isBraveWallet,
                            isXverse: p.isXverse,
                            constructorName: p.constructor?.name
                        });
                    });
                }
            }

            // Check user agent
            console.log('User Agent:', navigator.userAgent);

            // Check current connection state
            console.log('Current connection state:', {
                connectedWallet: connectedWallet,
                connectedAddress: connectedAddress ? (connectedAddress.substring(0, 6) + '...' + connectedAddress.substring(connectedAddress.length - 4)) : null,
                currentDirection: currentDirection
            });

            // Test wallet availability
            const wallets = getAvailableWallets();
            console.log(`\n📋 Available wallets for ${currentDirection}:`);
            wallets.forEach(wallet => {
                const isAvailable = wallet.isAvailable();
                console.log(`  ${isAvailable ? '✅' : '❌'} ${wallet.name} (${wallet.type})`);
            });

            return {
                hasEthereum: !!window.ethereum,
                hasStarknet: !!window.starknet,
                hasXverse: !!window.xverse,
                connectedWallet: connectedWallet,
                connectedAddress: connectedAddress,
                availableWallets: wallets.filter(w => w.isAvailable()).length,
                totalWallets: wallets.length
            };
        };

        // Specific Xverse wallet debugging
        window.debugXverseWallet = function() {
            console.log('🔍 Xverse Wallet Specific Debug');
            console.log('==============================');

            // Check all possible Xverse indicators
            console.log('window.xverse:', !!window.xverse);
            if (window.xverse) {
                console.log('window.xverse properties:', Object.getOwnPropertyNames(window.xverse));
                console.log('window.xverse.isXverse:', window.xverse.isXverse);
            }

            console.log('window.ethereum.isXverse:', window.ethereum?.isXverse);
            console.log('window.ethereum.constructor.name:', window.ethereum?.constructor?.name);

            if (window.ethereum?.providers) {
                console.log('Checking providers for Xverse...');
                window.ethereum.providers.forEach((p, i) => {
                    console.log(`Provider ${i}:`, {
                        isXverse: p.isXverse,
                        constructorName: p.constructor?.name,
                        hasRequest: typeof p.request === 'function'
                    });
                });
            }

            // Check user agent
            const userAgent = navigator.userAgent.toLowerCase();
            console.log('Xverse in user agent:', userAgent.includes('xverse'));

            // Test Xverse wallet availability specifically
            const xverseWallet = {
                id: 'xverse',
                name: 'Xverse Wallet',
                type: 'Bitcoin',
                icon: 'fas fa-bitcoin',
                isAvailable: () => {
                    try {
                        if (typeof window !== 'undefined' && window.xverse) {
                            return true;
                        }

                        if (window.ethereum) {
                            if (window.ethereum.isXverse ||
                                window.ethereum.constructor?.name?.includes('Xverse') ||
                                window.ethereum.constructor?.toString().toLowerCase().includes('xverse')) {
                                return true;
                            }

                            if (window.ethereum.providers && Array.isArray(window.ethereum.providers)) {
                                const xverseProvider = window.ethereum.providers.find(p =>
                                    p.isXverse ||
                                    p.constructor?.name?.includes('Xverse') ||
                                    p.constructor?.toString().toLowerCase().includes('xverse')
                                );
                                if (xverseProvider) return true;
                            }
                        }

                        if (typeof navigator !== 'undefined') {
                            const userAgent = navigator.userAgent.toLowerCase();
                            if (userAgent.includes('xverse') ||
                                userAgent.includes('xversewallet') ||
                                userAgent.includes('xverse-bitcoin')) {
                                return true;
                            }
                        }

                        if (typeof window !== 'undefined') {
                            const xverseProps = ['xverse', 'Xverse', 'xverseWallet', 'XverseWallet'];
                            for (const prop of xverseProps) {
                                if (window[prop] && (window[prop].isXverse || window[prop].isConnected)) {
                                    return true;
                                }
                            }
                        }

                        if (window.ethereum && typeof window.ethereum.request === 'function') {
                            return true;
                        }

                        return false;
                    } catch (error) {
                        console.warn('Error detecting Xverse wallet:', error);
                        return false;
                    }
                }
            };

            const isAvailable = xverseWallet.isAvailable();
            console.log('Xverse wallet available:', isAvailable);

            if (isAvailable) {
                console.log('✅ Xverse wallet should be connectable');
                console.log('💡 Try clicking the Xverse button in the navigation bar');
            } else {
                console.log('❌ Xverse wallet not detected');
                console.log('🔧 Troubleshooting steps:');
                console.log('  1. Make sure Xverse extension is installed and enabled');
                console.log('  2. Refresh the page');
                console.log('  3. Try running refreshWalletDetection()');
                console.log('  4. Check if Xverse appears in the wallet modal');
            }

            return {
                isAvailable,
                hasWindowXverse: !!window.xverse,
                hasEthereumXverse: !!window.ethereum?.isXverse,
                hasXverseInProviders: window.ethereum?.providers?.some(p => p.isXverse) || false,
                hasXverseInUserAgent: userAgent.includes('xverse')
            };
        };


        // Insert debug panel at the top of the bridge container
        const bridgeContainer = document.querySelector('.bridge-container');
        if (bridgeContainer) {
            bridgeContainer.insertBefore(debugPanel, bridgeContainer.firstChild);
        }
    </script>
</body>
</html>